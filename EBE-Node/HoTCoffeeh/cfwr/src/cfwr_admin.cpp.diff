1,10c1,10
< #include<iostream>
< #include<sstream>
< #include<string>
< #include<fstream>
< #include<cmath>
< #include<iomanip>
< #include<vector>
< #include<stdio.h>
< #include<time.h>
< #include<algorithm>
---
> #include <iostream>
> #include <sstream>
> #include <string>
> #include <fstream>
> #include <cmath>
> #include <iomanip>
> #include <vector>
> #include <stdio.h>
> #include <time.h>
> #include <algorithm>
13,19c13,19
< #include "cfwr.h"
< #include "cfwr_lib.h"
< #include "Arsenal.h"
< #include "chebyshev.h"
< #include "Stopwatch.h"
< #include "gauss_quadrature.h"
< #include "bessel.h"
---
> #include "../include/cfwr.h"
> #include "../include/cfwr_lib.h"
> #include "../include/Arsenal.h"
> #include "../include/chebyshev.h"
> #include "../include/Stopwatch.h"
> #include "../include/gauss_quadrature.h"
> #include "../include/bessel.h"
30,31c30,36
< CorrelationFunction::CorrelationFunction(ParameterReader * paraRdr_in, particle_info* particle, particle_info* all_particles_in, int Nparticle_in,
< 					vector<int> chosen_resonances_in, int particle_idx, ofstream& myout)
---
> CorrelationFunction::CorrelationFunction(
> 	ParameterReader * paraRdr_in,
> 	particle_info* particle,
> 	particle_info* all_particles_in,
> 	int Nparticle_in,
> 	vector<int> chosen_resonances_in,
> 	int particle_idx, ofstream& myout)
35,74c40,98
< 	USE_PLANE_PSI_ORDER = paraRdr->getVal("use_plane_psi_order");
< 	INCLUDE_DELTA_F = paraRdr->getVal("include_delta_f");
< 	GROUPING_PARTICLES = paraRdr->getVal("grouping_particles");
< 	PARTICLE_DIFF_TOLERANCE = paraRdr->getVal("particle_diff_tolerance");
< 	IGNORE_LONG_LIVED_RESONANCES = paraRdr->getVal("ignore_long_lived_resonances");
< 	FIT_WITH_PROJECTED_CFVALS = paraRdr->getVal("fit_with_projected_cfvals");
< 	FLESH_OUT_CF = paraRdr->getVal("flesh_out_cf");
< 	CALCULATE_CF_MODE = paraRdr->getVal("calculate_CF_mode");
< 	n_order = paraRdr->getVal("n_order");
< 	tol = paraRdr->getVal("tolerance");
< 	flagneg = paraRdr->getVal("flag_negative_S");
< 	max_lifetime = paraRdr->getVal("max_lifetime");
< 
< 	//set header info
< 	n_pT_pts = paraRdr->getVal("CF_npT");
< 	n_pphi_pts = paraRdr->getVal("CF_npphi");
< 	n_pY_pts = paraRdr->getVal("CF_npY");
< 	nKT = paraRdr->getVal("nKT");
< 	nKphi = paraRdr->getVal("nKphi");
< 	KT_min = paraRdr->getVal("KTmin");
< 	KT_max = paraRdr->getVal("KTmax");
< 	qtnpts = paraRdr->getVal("qtnpts");
< 	qxnpts = paraRdr->getVal("qxnpts");
< 	qynpts = paraRdr->getVal("qynpts");
< 	qznpts = paraRdr->getVal("qznpts");
< 	delta_qt = 0.1; //dummy value; this gets reset later
< 	delta_qx = paraRdr->getVal("delta_qx");
< 	delta_qy = paraRdr->getVal("delta_qy");
< 	delta_qz = paraRdr->getVal("delta_qz");
< 	init_qt = -0.5*double(qtnpts-1)*delta_qt;
< 	init_qx = -0.5*double(qxnpts-1)*delta_qx;
< 	init_qy = -0.5*double(qynpts-1)*delta_qy;
< 	init_qz = -0.5*double(qznpts-1)*delta_qz;
< 
< 	n_alpha_points = 31;
< 	//n_alpha_points_PIONS = 101;
< 
< 	new_nqxpts = ( qxnpts > 1 ) ? new_nqpts : 1;
< 	new_nqypts = ( qynpts > 1 ) ? new_nqpts : 1;
< 	new_nqzpts = ( qznpts > 1 ) ? new_nqpts : 1;
---
> 	USE_PLANE_PSI_ORDER
> 		= paraRdr->getVal("use_plane_psi_order");
> 	INCLUDE_DELTA_F
> 		= paraRdr->getVal("include_delta_f");
> 	GROUPING_PARTICLES
> 		= paraRdr->getVal("grouping_particles");
> 	PARTICLE_DIFF_TOLERANCE
> 		= paraRdr->getVal("particle_diff_tolerance");
> 	IGNORE_LONG_LIVED_RESONANCES
> 		= paraRdr->getVal("ignore_long_lived_resonances");
> 	FIT_WITH_PROJECTED_CFVALS
> 		= paraRdr->getVal("fit_with_projected_cfvals");
> 	FLESH_OUT_CF
> 		= paraRdr->getVal("flesh_out_cf");
> 	CALCULATE_CF_MODE
> 		= paraRdr->getVal("calculate_CF_mode");
> 
> 	n_order			= paraRdr->getVal("n_order");
> 	tol			= paraRdr->getVal("tolerance");
> 	flagneg			= paraRdr->getVal("flag_negative_S");
> 	max_lifetime	= paraRdr->getVal("max_lifetime");
> 
> 	//Set header info
> 	//Define various grid sizes
> 	// - SP momentum points at which to evaluate correlation function
> 	n_pT_pts		= paraRdr->getVal("CF_npT");
> 	n_pphi_pts		= paraRdr->getVal("CF_npphi");
> 	n_pY_pts		= paraRdr->getVal("CF_npY");
> 	// - pair momenta points at which to interpolate HBT results
> 	nKT			= paraRdr->getVal("nKT");
> 	nKphi			= paraRdr->getVal("nKphi");
> 	KT_min			= paraRdr->getVal("KTmin");
> 	KT_max			= paraRdr->getVal("KTmax");
> 	// - relative momentum points at which to evaluate
> 	//   correlation function
> 	qtnpts			= paraRdr->getVal("qtnpts");
> 	qxnpts			= paraRdr->getVal("qxnpts");
> 	qynpts			= paraRdr->getVal("qynpts");
> 	qznpts			= paraRdr->getVal("qznpts");
> 	// - step size in q directions
> 	delta_qt		= 0.1;
> 	delta_qx		= paraRdr->getVal("delta_qx");
> 	delta_qy		= paraRdr->getVal("delta_qy");
> 	delta_qz		= paraRdr->getVal("delta_qz");
> 	// - minimum value in each q direction
> 	init_qt			= -0.5*double(qtnpts-1)*delta_qt;
> 	init_qx			= -0.5*double(qxnpts-1)*delta_qx;
> 	init_qy			= -0.5*double(qynpts-1)*delta_qy;
> 	init_qz			= -0.5*double(qznpts-1)*delta_qz;
> 
> 	// - used for rapid Chebyshev evaluation of complex Bessel functions;
> 	//   31 points works reasonably well
> 	n_alpha_points	= 31;
> 
> 	// - number of points to use when fleshing out correlation
> 	//   function in each direction
> 	new_nqxpts		= ( qxnpts > 1 ) ? new_nqpts : 1;
> 	new_nqypts		= ( qynpts > 1 ) ? new_nqpts : 1;
> 	new_nqzpts		= ( qznpts > 1 ) ? new_nqpts : 1;
77c101
< 	global_out_stream_ptr = &myout;
---
> 	out			= &myout;
79,85c103,111
< 	//particle information (both final-state particle used in HBT and all decay decay_channels)
< 	particle_name = particle->name;
< 	particle_mass = particle->mass;
< 	particle_sign = particle->sign;
< 	particle_gspin = particle->gspin;
< 	particle_id = particle_idx;
< 	target_particle_id = particle_id;
---
> 	//particle information (both for the final-state particle
> 	//used in HBT correlation function and for all decay channels)
> 	particle_name	= particle->name;
> 	particle_mass	= particle->mass;
> 	particle_sign	= particle->sign;
> 	particle_gspin	= particle->gspin;
> 	particle_id	= particle_idx;
> 	target_particle_id
> 					= particle_id;
87,89c113,120
< 	S_prefactor = 1.0/(8.0*(M_PI*M_PI*M_PI))/hbarC/hbarC/hbarC;
< 	current_total_resonance_percentage = 0.0;
< 	all_particles = all_particles_in;
---
> 
> 	current_total_resonance_percentage
> 					= 0.0;
> 
> 	// load all particle information
> 	all_particles	= all_particles_in;
> 
> 	// load list of chosen resonances to use in calculation
93c124,125
< 		cout << "chosen_resonances_in[" << icr << "] = " << chosen_resonances_in[icr] << endl;
---
> 		//cout << "chosen_resonances_in[" << icr << "] = "
> 		//		<< chosen_resonances_in[icr] << endl;
95,96c127,131
< 	thermal_pions_only = false;
< 	Nparticle = Nparticle_in;
---
> 
> 	// total number of particles included in database
> 	Nparticle		= Nparticle_in;
> 
> 	// total number of resonances being used
98,103d132
< 	read_in_all_dN_dypTdpTdphi = false;
< 	output_all_dN_dypTdpTdphi = true;
< 	//currentfolderindex = -1;
< 	current_level_of_output = 0;
< 	//qspace_cs_slice_length = qnpts*qnpts*qnpts*qnpts*ntrig;		//factor of 4 for sin or cos
< 	qspace_cs_slice_length = qxnpts*qynpts*ntrig;		//factor of 4 for sin or cos, real or imaginary
105c134,145
< 	ipY0 = ( USE_RAPIDITY_SYMMETRY ) ? 0 : (n_pY_pts - 1) / 2;	//define the point where pY==0
---
> 	// set some defaults
> 	thermal_pions_only			= false;
> 	read_in_all_dN_dypTdpTdphi	= false;
> 	output_all_dN_dypTdpTdphi	= true;
> 	current_level_of_output		= 0;
> 
> 	//Length of q-vectors, counting complexity and even/odd:
> 	//factor of 4 for sin or cos, real or imaginary
> 	qspace_cs_slice_length		= qxnpts*qynpts*ntrig;
> 
> 	//Define index of the point where pY==0
> 	ipY0 = ( USE_RAPIDITY_SYMMETRY ) ? 0 : (n_pY_pts - 1) / 2;
112,118c152,156
< 	//sort by proximity to origin (where CF is largest) and do those points first
< 	Set_sorted_q_pts_list();
< 
< 	v_min = -1.;
< 	v_max = 1.;
< 	zeta_min = 0.;
< 	zeta_max = M_PI;
---
> 	//Define limits of phase-space integrals
> 	v_min		= -1.;
> 	v_max		= 1.;
> 	zeta_min	= 0.;
> 	zeta_max	= M_PI;
119a158
> 	//Set whether viscous corrections included
122,134c161,177
< //****************************************************************************************************
< 	current_resonance_mass = 0.0;
< 	current_resonance_mu = 0.0;
< 	current_resonance_Gamma = 0.0;
< 	current_resonance_total_br = 0.0;
< 	current_resonance_decay_masses = new double [2];
< 	current_resonance_decay_masses[0] = 0.0;
< 	current_resonance_decay_masses[1] = 0.0;
< 	previous_resonance_particle_id = -1;
< 	previous_decay_channel_idx = -1;				//different for each decay channel
< 	previous_resonance_mass = 0.0;
< 	previous_resonance_Gamma = 0.0;
< 	previous_resonance_total_br = 0.0;
---
> 	// Set up keeping track of current and previous resonances
> 	current_resonance_mass				= 0.0;
> 	current_resonance_mu				= 0.0;
> 	current_resonance_Gamma				= 0.0;
> 	current_resonance_total_br			= 0.0;
> 	current_resonance_decay_masses		= new double [2];
> 	current_resonance_decay_masses[0]	= 0.0;
> 	current_resonance_decay_masses[1]	= 0.0;
> 	previous_resonance_particle_id		= -1;
> 	// this is different for each decay channel,
> 	// not just each resonance
> 	previous_decay_channel_idx			= -1;
> 	previous_resonance_mass				= 0.0;
> 	previous_resonance_Gamma			= 0.0;
> 	previous_resonance_total_br		= 0.0;
> 
> 	// thermal pions only
140c183,184
< 		if (VERBOSE > 0) *global_out_stream_ptr << "Thermal pion(+) only!" << endl;
---
> 		if (VERBOSE > 0)
> 			*out << "Thermal pion(+) only!" << endl;
142c186,187
< 		decay_channels[0].resonance_decay_masses = new double [Maxdecaypart];	// Maxdecaypart == 5
---
> 		decay_channels[0].resonance_decay_masses
> 			= new double [Maxdecaypart];
143a189
> 	// if there are resonances to consider
146,152c192,208
< 		//n_decay_channels is actually total number of decay channels which can generate pions
< 		//from chosen decay_channels
< 		n_decay_channels = get_number_of_decay_channels(chosen_resonances, all_particles);
< 		n_resonance = (int)chosen_resonances.size();
< 		if (VERBOSE > 0) *global_out_stream_ptr << "Computed n_decay_channels = " << n_decay_channels << endl
< 							<< "Computed n_resonance = " << n_resonance << endl;
< 		decay_channels = new decay_info [n_decay_channels];
---
> 		// n_decay_channels is total number of decay channels which
> 		// contribute to pion yield from chosen decay_channels
> 		n_decay_channels
> 			= get_number_of_decay_channels(chosen_resonances, all_particles);
> 		n_resonance
> 			= (int)chosen_resonances.size();
> 
> 		if (VERBOSE > 0)
> 			*out << "Computed n_decay_channels = "
> 					<< n_decay_channels << endl
> 					<< "Computed n_resonance = "
> 					<< n_resonance << endl;
> 
> 		decay_channels
> 			= new decay_info [n_decay_channels];
> 
> 		// now loop over all resonances and load decay channel info
156,158c212,220
< 			particle_info particle_temp = all_particles[chosen_resonances[icr]];
< 			if (VERBOSE > 0) *global_out_stream_ptr << "Loading resonance: " << particle_temp.name
< 					<< ", chosen_resonances[" << icr << "] = " << chosen_resonances[icr] << endl;
---
> 			particle_info particle_temp
> 				= all_particles[chosen_resonances[icr]];
> 
> 			if (VERBOSE > 0)
> 				*out << "Loading resonance: "
> 						<< particle_temp.name
> 						<< ", chosen_resonances[" << icr << "] = "
> 						<< chosen_resonances[icr] << endl;
> 
161,162c223,227
< 				if (VERBOSE > 0) *global_out_stream_ptr << "Current temp_idx = " << temp_idx << endl;
< 				if (temp_idx == n_decay_channels)	//i.e., all contributing decay channels have been loaded
---
> 				if (VERBOSE > 0)
> 					*out << "Current temp_idx = " << temp_idx << endl;
> 
> 				// if all contributing decay channels have been loaded
> 				if (temp_idx == n_decay_channels)
164d228
< 				decay_channels[temp_idx].resonance_name = particle_temp.name;		// set name of resonance
166,169c230
< 				//check if effective branching is too small for inclusion in source variances
< 				bool effective_br_is_too_small = false;
< 				if (particle_temp.decays_effective_branchratio[idecay] <= 1.e-12)
< 					effective_br_is_too_small = true;
---
> 				decay_info decay_to_load;
171,175c232,233
< 				decay_channels[temp_idx].resonance_particle_id = chosen_resonances[icr];	// set index of resonance in all_particles
< 				decay_channels[temp_idx].resonance_idx = icr;					// set index of resonance in chosen_resonances
< 				decay_channels[temp_idx].resonance_decay_masses = new double [Maxdecaypart];	// Maxdecaypart == 5
< 				decay_channels[temp_idx].resonance_decay_monvals = new int [Maxdecaypart];	// Maxdecaypart == 5
< 				decay_channels[temp_idx].resonance_decay_Gammas = new double [Maxdecaypart];	// Maxdecaypart == 5
---
> 				// set name of resonance
> 				decay_to_load.resonance_name = particle_temp.name;
176a235,240
> 				// check if effective branching is too small for inclusion
> 				// in source variances
> 				bool effective_br_is_too_small = false;
> 				if (particle_temp.decays_effective_branchratio[idecay]
> 						<= 1.e-12)
> 					effective_br_is_too_small = true;
177a242,253
> 				// set index of resonance in all_particles
> 				decay_to_load.resonance_particle_id
> 						= chosen_resonances[icr];
> 				// set index of resonance in chosen_resonances
> 				decay_to_load.resonance_idx
> 						= icr;
> 				decay_to_load.resonance_decay_monvals
> 						= new int [Maxdecaypart];
> 				decay_to_load.resonance_decay_masses
> 						= new double [Maxdecaypart];
> 				decay_to_load.resonance_decay_Gammas
> 						= new double [Maxdecaypart];
179c255
< 				//*** SETTING RESONANCE DECAY MASSES DIFFERENTLY FOR NEW ANALYZE SF
---
> 				// Set resonance decay masses
182c258,260
< 					decay_channels[temp_idx].resonance_decay_monvals[ii] = particle_temp.decays_part[idecay][ii];
---
> 					decay_to_load.resonance_decay_monvals[ii]
> 						= particle_temp.decays_part[idecay][ii];
> 
185,187c263,266
< 						decay_channels[temp_idx].resonance_decay_masses[ii] = 0.0;
< 						decay_channels[temp_idx].resonance_decay_Gammas[ii] = 0.0;
< 
---
> 						decay_to_load.resonance_decay_masses[ii]
> 							= 0.0;
> 						decay_to_load.resonance_decay_Gammas[ii]
> 							= 0.0;
191,194c270,278
< 						int tempID = lookup_particle_id_from_monval(all_particles, Nparticle, particle_temp.decays_part[idecay][ii]);
< 						decay_channels[temp_idx].resonance_decay_masses[ii] = all_particles[tempID].mass;
< 						decay_channels[temp_idx].resonance_decay_Gammas[ii] = all_particles[tempID].width;
< 
---
> 						int tempID
> 							= lookup_particle_id_from_monval(
> 								all_particles,
> 								Nparticle,
> 								particle_temp.decays_part[idecay][ii]);
> 						decay_to_load.resonance_decay_masses[ii]
> 							= all_particles[tempID].mass;
> 						decay_to_load.resonance_decay_Gammas[ii]
> 							= all_particles[tempID].width;
197,204c281,296
< 				decay_channels[temp_idx].resonance_mu = particle_temp.mu;
< 				decay_channels[temp_idx].resonance_gspin = particle_temp.gspin;
< 				decay_channels[temp_idx].resonance_sign = particle_temp.sign;
< 				decay_channels[temp_idx].resonance_mass = particle_temp.mass;
< 				decay_channels[temp_idx].nbody = abs(particle_temp.decays_Npart[idecay]);
< 				decay_channels[temp_idx].resonance_Gamma = particle_temp.width;
< 				decay_channels[temp_idx].resonance_total_br = particle_temp.decays_effective_branchratio[idecay];
< 				decay_channels[temp_idx].resonance_direct_br = particle_temp.decays_branchratio[idecay];
---
> 				decay_to_load.resonance_mu
> 							= particle_temp.mu;
> 				decay_to_load.resonance_gspin
> 							= particle_temp.gspin;
> 				decay_to_load.resonance_sign
> 							= particle_temp.sign;
> 				decay_to_load.resonance_mass
> 							= particle_temp.mass;
> 				decay_to_load.nbody
> 							= abs(particle_temp.decays_Npart[idecay]);
> 				decay_to_load.resonance_Gamma
> 							= particle_temp.width;
> 				decay_to_load.resonance_total_br
> 							= particle_temp.decays_effective_branchratio[idecay];
> 				decay_to_load.resonance_direct_br
> 							= particle_temp.decays_branchratio[idecay];
206c298,299
< 				//check if particle lifetime is too long for inclusion in source variances
---
> 				//check if particle lifetime is too long for
> 				//inclusion in source variances
208,209c301,332
< 				//if (decay_channels[temp_idx].resonance_Gamma < hbarC / max_lifetime)
< 				//	lifetime_is_too_long = true;		//i.e., for lifetimes longer than 100 fm/c, skip decay channel
---
> 				//if (decay_channels[temp_idx].resonance_Gamma
> 				//		< hbarC / max_lifetime)
> 				//	lifetime_is_too_long = true;
> 				//i.e., for lifetimes longer than 100 fm/c, skip decay channel
> 
> 				if (VERBOSE > 0)
> 					*out << "Resonance = "
> 							<< decay_to_load.resonance_name
> 							<< ", decay channel " << idecay + 1
> 							<< ": mu=" << decay_to_load.resonance_mu
> 							<< ", gs=" << decay_to_load.resonance_gspin
> 							<< ", sign=" << decay_to_load.resonance_sign
> 							<< ", M=" << decay_to_load.resonance_mass
> 							<< ", nbody=" << decay_to_load.nbody
> 							<< ", Gamma=" << decay_to_load.resonance_Gamma
> 							<< ", total br=" << decay_to_load.resonance_total_br
> 							<< ", direct br="
> 							<< decay_to_load.resonance_direct_br << endl;
> 
> 				if (VERBOSE > 0)
> 					*out << "Resonance = "
> 							<< decay_to_load.resonance_name << ": ";
> 
> 				for (int dec_pt_idx = 0;
> 						dec_pt_idx < decay_to_load.nbody;
> 						dec_pt_idx++)
> 				if (VERBOSE > 0)
> 					*out << "m[" << dec_pt_idx << "] = "
> 							<< decay_to_load.resonance_decay_masses[dec_pt_idx]
> 							<< "   "
> 							<< decay_to_load.resonance_decay_monvals[dec_pt_idx]
> 							<< "   ";
211,223c334
< 				if (VERBOSE > 0) *global_out_stream_ptr << "Resonance = " << decay_channels[temp_idx].resonance_name << ", decay channel " << idecay + 1
< 						<< ": mu=" << decay_channels[temp_idx].resonance_mu
< 						<< ", gs=" << decay_channels[temp_idx].resonance_gspin << ", sign=" << decay_channels[temp_idx].resonance_sign
< 						<< ", M=" << decay_channels[temp_idx].resonance_mass << ", nbody=" << decay_channels[temp_idx].nbody
< 						<< ", Gamma=" << decay_channels[temp_idx].resonance_Gamma << ", total br=" << decay_channels[temp_idx].resonance_total_br
< 						<< ", direct br=" << decay_channels[temp_idx].resonance_direct_br << endl;
< 
< 				if (VERBOSE > 0) *global_out_stream_ptr << "Resonance = " << decay_channels[temp_idx].resonance_name << ": ";
< 				for (int decay_part_idx = 0; decay_part_idx < decay_channels[temp_idx].nbody; decay_part_idx++)
< 					if (VERBOSE > 0) *global_out_stream_ptr << "m[" << decay_part_idx << "] = "
< 						<< decay_channels[temp_idx].resonance_decay_masses[decay_part_idx] << "	  "
< 						<< decay_channels[temp_idx].resonance_decay_monvals[decay_part_idx] << "   ";
< 				if (VERBOSE > 0) *global_out_stream_ptr << endl << endl;
---
> 				if (VERBOSE > 0) *out << endl << endl;
226,228c337,340
< 				// and decay channel contains at least one target daughter particle,
< 				// include channel
< 				decay_channels[temp_idx].include_channel = !lifetime_is_too_long && !effective_br_is_too_small;
---
> 				// and decay channel contains at least one target daughter
> 				// particle, include channel
> 				decay_to_load.include_channel
> 					= !lifetime_is_too_long && !effective_br_is_too_small;
230c342,343
< 				temp_idx++;
---
> 				decay_channels[temp_idx++]
> 					= decay_to_load;
235,238c348,358
< 	//try flattening
< 	const int giant_flat_array_size = n_pT_pts * n_pphi_pts * n_pY_pts * qxnpts * qynpts * ntrig;
< 	thermal_target_dN_dypTdpTdphi_moments = new double [giant_flat_array_size];
< 	current_dN_dypTdpTdphi_moments = new double [giant_flat_array_size];
---
> 	/////////////////////////
> 	//Create flattened arrays
> 
> 	// - space-time moments in a given (qt,qz)-loop
> 	const int giant_flat_array_size
> 		= n_pT_pts * n_pphi_pts * n_pY_pts
> 			* qxnpts * qynpts * ntrig;
> 	thermal_target_dN_dypTdpTdphi_moments
> 		= new double [giant_flat_array_size];
> 	current_dN_dypTdpTdphi_moments
> 		= new double [giant_flat_array_size];
241,242c361,362
< 		thermal_target_dN_dypTdpTdphi_moments[i] = 0.0;
< 		current_dN_dypTdpTdphi_moments[i] = 0.0;
---
> 		thermal_target_dN_dypTdpTdphi_moments[i]	= 0.0;
> 		current_dN_dypTdpTdphi_moments[i]			= 0.0;
244,246c364,372
< 	const int full_size = n_pT_pts * n_pphi_pts * qtnpts * qxnpts * qynpts * qznpts * ntrig;
< 	thermal_target_Yeq0_moments = new double [full_size];
< 	full_target_Yeq0_moments = new double [full_size];
---
> 
> 	// - all space-time moments
> 	const int full_size
> 		= n_pT_pts * n_pphi_pts
> 			* qtnpts * qxnpts * qynpts * qznpts * ntrig;
> 	thermal_target_Yeq0_moments
> 		= new double [full_size];
> 	full_target_Yeq0_moments
> 		= new double [full_size];
249,250c375,376
< 		thermal_target_Yeq0_moments[i] = 0.0;
< 		full_target_Yeq0_moments[i] = 0.0;
---
> 		thermal_target_Yeq0_moments[i]	= 0.0;
> 		full_target_Yeq0_moments[i]	= 0.0;
252a379
> 	// Set the list of q points
262,264c389,395
< 	res_log_info = new double * [n_pT_pts * n_pphi_pts * n_pY_pts];
< 	res_sign_info = new double * [n_pT_pts * n_pphi_pts * n_pY_pts];
< 	res_moments_info = new double * [n_pT_pts * n_pphi_pts * n_pY_pts];
---
> 	// - flattened arrays for resonance interpolation
> 	res_log_info
> 		= new double * [n_pT_pts * n_pphi_pts * n_pY_pts];
> 	res_sign_info
> 		= new double * [n_pT_pts * n_pphi_pts * n_pY_pts];
> 	res_moments_info
> 		= new double * [n_pT_pts * n_pphi_pts * n_pY_pts];
267,269c398,403
< 		res_log_info[i] = new double [qspace_cs_slice_length];
< 		res_sign_info[i] = new double [qspace_cs_slice_length];
< 		res_moments_info[i] = new double [qspace_cs_slice_length];
---
> 		res_log_info[i]
> 			= new double [qspace_cs_slice_length];
> 		res_sign_info[i]
> 			= new double [qspace_cs_slice_length];
> 		res_moments_info[i]
> 			= new double [qspace_cs_slice_length];
272,273c406,407
< 			res_log_info[i][ii] = 0.0;
< 			res_sign_info[i][ii] = 0.0;
---
> 			res_log_info[i][ii]	= 0.0;
> 			res_sign_info[i][ii]	= 0.0;
279c413
< 	spectra = new double ** [Nparticle];
---
> 	spectra			= new double ** [Nparticle];
281,282c415,416
< 	log_spectra = new double ** [Nparticle];
< 	sign_spectra = new double ** [Nparticle];
---
> 	log_spectra	= new double ** [Nparticle];
> 	sign_spectra	= new double ** [Nparticle];
285c419
< 		spectra[ir] = new double * [n_pT_pts];
---
> 		spectra[ir]		= new double * [n_pT_pts];
287,288c421,422
< 		log_spectra[ir] = new double * [n_pT_pts];
< 		sign_spectra[ir] = new double * [n_pT_pts];
---
> 		log_spectra[ir]		= new double * [n_pT_pts];
> 		sign_spectra[ir]	= new double * [n_pT_pts];
291,294c425,428
< 			spectra[ir][ipT] = new double [n_pphi_pts];
< 			thermal_spectra[ir][ipT] = new double [n_pphi_pts];
< 			log_spectra[ir][ipT] = new double [n_pphi_pts];
< 			sign_spectra[ir][ipT] = new double [n_pphi_pts];
---
> 			spectra[ir][ipT]			= new double [n_pphi_pts];
> 			thermal_spectra[ir][ipT]	= new double [n_pphi_pts];
> 			log_spectra[ir][ipT]		= new double [n_pphi_pts];
> 			sign_spectra[ir][ipT]		= new double [n_pphi_pts];
297c431
< 				spectra[ir][ipT][ipphi] = 0.0;
---
> 				spectra[ir][ipT][ipphi]			= 0.0;
299,300c433,434
< 				log_spectra[ir][ipT][ipphi] = 0.0;
< 				sign_spectra[ir][ipT][ipphi] = 0.0;
---
> 				log_spectra[ir][ipT][ipphi]	= 0.0;
> 				sign_spectra[ir][ipT][ipphi]	= 0.0;
306,309c440,443
< 	v_pts = new double [n_v_pts];
< 	v_wts = new double [n_v_pts];
< 	zeta_pts = new double [n_zeta_pts];
< 	zeta_wts = new double [n_zeta_pts];
---
> 	v_pts		= new double [n_v_pts];
> 	v_wts		= new double [n_v_pts];
> 	zeta_pts	= new double [n_zeta_pts];
> 	zeta_wts	= new double [n_zeta_pts];
312,314c446,456
< 	//syntax: int gauss_quadrature(int order, int kind, double alpha, double beta, double a, double b, double x[], double w[])
< 	gauss_quadrature(n_zeta_pts, 1, 0.0, 0.0, zeta_min, zeta_max, zeta_pts, zeta_wts);
< 	gauss_quadrature(n_v_pts, 1, 0.0, 0.0, v_min, v_max, v_pts, v_wts);
---
> 	//syntax: int gauss_quadrature(
> 	//				int order, int kind,
> 	//				double alpha, double beta,
> 	//				double a, double b,
> 	//				double x[], double w[])
> 	// - points for zeta integral
> 	gauss_quadrature(n_zeta_pts, 1, 0.0, 0.0,
> 						zeta_min, zeta_max, zeta_pts, zeta_wts);
> 	// - points for v integral
> 	gauss_quadrature(n_v_pts, 1, 0.0, 0.0,
> 						v_min, v_max, v_pts, v_wts);
315a458
> 	/////////////////////////////
317,319c460,473
< 	SP_pT = new double [n_pT_pts];
< 	SP_pT_wts = new double [n_pT_pts];
< 	SP_pphi = new double [n_pphi_pts];
---
> 
> 	// - pT points
> 	SP_pT		= new double [n_pT_pts];
> 	SP_pT_wts	= new double [n_pT_pts];
> 	gauss_quadrature(n_pT_pts, 5, 0.0, 0.0, 0.0,
> 						13.0*n_pT_pts/15.0, SP_pT, SP_pT_wts);
> 	//stratify_npts( 1e-6, 1.0+1e-6, 4.0, int(0.80*n_pT_pts), n_pT_pts, SP_pT );
> 
> 	cout << "CHECK SP_pT: " << endl;
> 	for (int ipt = 0; ipt < n_pT_pts; ++ipt)
> 		cout << ipt << "   " << SP_pT[ipt] << endl;
> 
> 	// - pphi points
> 	SP_pphi		= new double [n_pphi_pts];
323,325d476
< 	gauss_quadrature(n_pT_pts, 5, 0.0, 0.0, 0.0, 13.0*n_pT_pts/15.0, SP_pT, SP_pT_wts);
< 	for (int ipt = 0; ipt < n_pT_pts; ++ipt)
< 		cout << ipt << "   " << SP_pT[ipt] << endl;
327,328c478,481
< 	gauss_quadrature(n_pphi_pts, 1, 0.0, 0.0, Kphi_min, Kphi_max, SP_pphi, SP_pphi_wts);
< 	for(int ipphi=0; ipphi<n_pphi_pts; ipphi++)
---
> 	gauss_quadrature(n_pphi_pts, 1, 0.0, 0.0,
> 						Kphi_min, Kphi_max, SP_pphi, SP_pphi_wts);
> 
> 	for(int ipphi=0; ipphi < n_pphi_pts; ipphi++)
332c485
< 		cout << ipphi << "   " << SP_pphi[ipphi] << endl;
---
> 		//cout << ipphi << "   " << SP_pphi[ipphi] << endl;
334,340c487,501
< 	//using this set of SP_Del_pY points to use Chebyshev interpolation for resonance feeddown
< 	SP_Del_pY = new double [n_pY_pts];
< 	double znodes[n_pY_pts];
< 	double tmp_tan = tan(M_PI / (4.0*n_pY_pts));
< 	adjusted_SP_Del_pY_minimum = ( USE_RAPIDITY_SYMMETRY and USE_ADJUSTED_MINIMUM ) ?
< 									-SP_Del_pY_max*tmp_tan*tmp_tan : SP_Del_pY_min;
< 	double local_scale = 0.5 * (adjusted_SP_Del_pY_minimum - SP_Del_pY_max);
---
> 
> 	// - pY points (Chebyshev nodes useful for resonance interpolation)
> 	SP_Del_pY		= new double [n_pY_pts];
> 	// pY points are fixed by two options:
> 	//	- USE_RAPIDITY_SYMMETRY determines whether to assume special symmetry
> 	//	  of space-time moments under certain reflections
> 	//	- USE_ADJUSTED_MINIMUM places the smallest pY node at Del_pY == 0
> 	double tmp_tan	= tan(M_PI / (4.0*n_pY_pts));
> 	adjusted_SP_Del_pY_minimum
> 					= ( USE_RAPIDITY_SYMMETRY and USE_ADJUSTED_MINIMUM ) ?
> 						- SP_Del_pY_max*tmp_tan*tmp_tan
> 						: SP_Del_pY_min;
> 
> 	// needed to define interpolation nodes
> 	double local_scale	= 0.5 * (adjusted_SP_Del_pY_minimum - SP_Del_pY_max);
342a504,505
> 	// set interpolation nodes
> 	double znodes[n_pY_pts];
345,347c508,514
< 		znodes[ipY] = - cos( M_PI*(2.*(ipY+1.) - 1.) / (2.*n_pY_pts) );
< 		SP_Del_pY[ipY] = local_center + local_scale * cos( M_PI*(2.*(ipY+1.) - 1.) / (2.*n_pY_pts) );
< 		cout << ipY << "   " << SP_Del_pY[ipY] << endl;
---
> 		znodes[ipY]	= - cos( M_PI * ( 2.*(ipY+1.) - 1. )
> 								/ (2.*n_pY_pts) );
> 		SP_Del_pY[ipY]	= local_center
> 							+ local_scale
> 							* cos( M_PI * ( 2.*(ipY+1.) - 1. )
> 								/ (2.*n_pY_pts) );
> 		//cout << ipY << "   " << SP_Del_pY[ipY] << endl;
350,356c517,520
< 	//spatial rapidity grid
< 	eta_s = new double [eta_s_npts];
< 	eta_s_weight = new double [eta_s_npts];
< 	gauss_quadrature(eta_s_npts, 1, 0.0, 0.0, eta_s_i, eta_s_f, eta_s, eta_s_weight);
< 	ch_eta_s = new double [eta_s_npts];
< 	sh_eta_s = new double [eta_s_npts];
< 	for (int ieta = 0; ieta < eta_s_npts; ieta++)
---
> 	// initialize here
> 	ch_SP_pY = new double [n_pY_pts];
> 	sh_SP_pY = new double [n_pY_pts];
> 	for (int ipY = 0; ipY < n_pY_pts; ++ipY)
358,359c522,523
< 		ch_eta_s[ieta] = cosh(eta_s[ieta]);
< 		sh_eta_s[ieta] = sinh(eta_s[ieta]);
---
> 		ch_SP_pY[ipY] = 0.0;
> 		sh_SP_pY[ipY] = 0.0;
361,367d524
< 	//alternative spatial rapidity grid
< 	base_Del_eta_s = new double [base_Del_eta_s_npts];
< 	base_Del_eta_s_weight = new double [base_Del_eta_s_npts];
< 	gauss_quadrature(base_Del_eta_s_npts, 6, 0.0, 0.0, 0.0, 1.0, base_Del_eta_s, base_Del_eta_s_weight);
< 	//base_ch_Del_eta_s = new double [base_Del_eta_s_npts];
< 	//base_sh_Del_eta_s = new double [base_Del_eta_s_npts];
< 	//if (1) exit (8);
369c526
< 	//also do Chebyshev function evaluations now
---
> 	// perform necessary Chebyshev function evaluations here
389c546
< 	// CAUTION: chebTcfs are NOT (yet) the coefficients which enter the final Chebyshev sum!!!
---
> 	//  CAUTION: chebTcfs are NOT (yet) the coefficients which enter the final Chebyshev sum!!!
391,397d547
< 	ch_SP_pY = new double [n_pY_pts];
< 	sh_SP_pY = new double [n_pY_pts];
< 	for (int ipY = 0; ipY < n_pY_pts; ++ipY)
< 	{
< 		ch_SP_pY[ipY] = 0.0;
< 		sh_SP_pY[ipY] = 0.0;
< 	}
399,408c549,556
< 	cout << "********************" << endl;
< 	for (int iqt = 0; iqt < qtnpts; iqt++)
< 		cout << "qt_pts[" << iqt << "] = " << qt_pts[iqt] << endl;
< 	cout << "********************" << endl;
< 	/*double * q_point = new double [4];
< 	for(int ipt=0; ipt<n_pT_pts; ipt++)
< 	for(int ipphi=0; ipphi<n_pphi_pts; ipphi++)
< 	for (int iqx = 0; iqx < qxnpts; ++iqx)
< 	for (int iqy = 0; iqy < qynpts; ++iqy)
< 	for (int iqz = 0; iqz < qznpts; ++iqz)
---
> 	// set spatial rapidity grid
> 	eta_s = new double [eta_s_npts];
> 	eta_s_weight = new double [eta_s_npts];
> 	gauss_quadrature(eta_s_npts, 1, 0.0, 0.0,
> 						eta_s_i, eta_s_f, eta_s, eta_s_weight);
> 	ch_eta_s = new double [eta_s_npts];
> 	sh_eta_s = new double [eta_s_npts];
> 	for (int ieta = 0; ieta < eta_s_npts; ieta++)
410,412c558,559
< 		Get_q_points(qx_pts[iqx], qy_pts[iqy], qz_pts[iqz], SP_pT[ipt], SP_pphi[ipphi], q_point);
< 		cout << "SANITY CHECK OF QT_INTERP: " << SP_pT[ipt] << "   " << SP_pphi[ipphi] << "   "
< 				<< q_point[0] << "   " << q_point[1] << "   " << q_point[2] << "   " << q_point[3] << endl;
---
> 		ch_eta_s[ieta] = cosh(eta_s[ieta]);
> 		sh_eta_s[ieta] = sinh(eta_s[ieta]);
415,416c562,566
< 	delete [] q_point;
< 	if (1) exit(8);*/
---
> 	//alternative spatial rapidity grid (POSSIBLY DELETE)
> 	base_Del_eta_s = new double [base_Del_eta_s_npts];
> 	base_Del_eta_s_weight = new double [base_Del_eta_s_npts];
> 	gauss_quadrature(base_Del_eta_s_npts, 6, 0.0, 0.0, 0.0, 1.0,
> 						base_Del_eta_s, base_Del_eta_s_weight);
417a568
> 	// vector for flow plane angles (0 by default)
421,482c572,637
< 	K_T = new double [nKT];
< 	double dK_T = (KT_max - KT_min)/(nKT - 1 + 1e-100);
< 	for (int i = 0; i < nKT; ++i)
< 		K_T[i] = KT_min + i*dK_T;
< 	//K_y = p_y;
< 	K_y = 0.;
< 	ch_K_y = cosh(K_y);
< 	sh_K_y = sinh(K_y);
< 	beta_l = sh_K_y/ch_K_y;
< 	K_phi = new double [nKphi];
< 	K_phi_weight = new double [nKphi];
< 	gauss_quadrature(nKphi, 1, 0.0, 0.0, Kphi_min, Kphi_max, K_phi, K_phi_weight);
< 
< 	//set HBT radii
< 	R2_side_GF = new double * [n_pT_pts];
< 	R2_out_GF = new double * [n_pT_pts];
< 	R2_long_GF = new double * [n_pT_pts];
< 	R2_outside_GF = new double * [n_pT_pts];
< 	R2_sidelong_GF = new double * [n_pT_pts];
< 	R2_outlong_GF = new double * [n_pT_pts];
< 
< 	R2_side_GF_C = new double * [nKT];
< 	R2_out_GF_C = new double * [nKT];
< 	R2_long_GF_C = new double * [nKT];
< 	R2_outside_GF_C = new double * [nKT];
< 	R2_sidelong_GF_C = new double * [nKT];
< 	R2_outlong_GF_C = new double * [nKT];
< 
< 	R2_side_GF_S = new double * [nKT];
< 	R2_out_GF_S = new double * [nKT];
< 	R2_long_GF_S = new double * [nKT];
< 	R2_outside_GF_S = new double * [nKT];
< 	R2_sidelong_GF_S = new double * [nKT];
< 	R2_outlong_GF_S = new double * [nKT];
< 
< 	R2_side_err = new double * [n_pT_pts];
< 	R2_out_err = new double * [n_pT_pts];
< 	R2_long_err = new double * [n_pT_pts];
< 	R2_outside_err = new double * [n_pT_pts];
< 	R2_sidelong_err = new double * [n_pT_pts];
< 	R2_outlong_err = new double * [n_pT_pts];
< 
< 	R2_side_QM = new double * [n_pT_pts];
< 	R2_out_QM = new double * [n_pT_pts];
< 	R2_long_QM = new double * [n_pT_pts];
< 	R2_outside_QM = new double * [n_pT_pts];
< 	R2_sidelong_QM = new double * [n_pT_pts];
< 	R2_outlong_QM = new double * [n_pT_pts];
< 
< 	R2_side_QM_C = new double * [nKT];
< 	R2_out_QM_C = new double * [nKT];
< 	R2_long_QM_C = new double * [nKT];
< 	R2_outside_QM_C = new double * [nKT];
< 	R2_sidelong_QM_C = new double * [nKT];
< 	R2_outlong_QM_C = new double * [nKT];
< 
< 	R2_side_QM_S = new double * [nKT];
< 	R2_out_QM_S = new double * [nKT];
< 	R2_long_QM_S = new double * [nKT];
< 	R2_outside_QM_S = new double * [nKT];
< 	R2_sidelong_QM_S = new double * [nKT];
< 	R2_outlong_QM_S = new double * [nKT];
---
> 	// - KT
> 	K_T			= new double [nKT];
> 	double dK_T	= (KT_max - KT_min)/(nKT - 1 + 1e-100);
> 	for (int i = 0; i < nKT; ++i) K_T[i] = KT_min + i*dK_T;
> 
> 	// - Kphi
> 	K_phi			= new double [nKphi];
> 	K_phi_weight	= new double [nKphi];
> 	gauss_quadrature(nKphi, 1, 0.0, 0.0,
> 						Kphi_min, Kphi_max, K_phi, K_phi_weight);
> 
> 	// - KY
> 	K_y			= 0.;
> 	ch_K_y			= cosh(K_y);
> 	sh_K_y			= sinh(K_y);
> 	beta_l			= sh_K_y/ch_K_y;
> 
> 	// set HBT radii
> 	R2_side_GF			= new double * [n_pT_pts];
> 	R2_out_GF			= new double * [n_pT_pts];
> 	R2_long_GF			= new double * [n_pT_pts];
> 	R2_outside_GF		= new double * [n_pT_pts];
> 	R2_sidelong_GF		= new double * [n_pT_pts];
> 	R2_outlong_GF		= new double * [n_pT_pts];
> 
> 	R2_side_GF_C		= new double * [nKT];
> 	R2_out_GF_C		= new double * [nKT];
> 	R2_long_GF_C		= new double * [nKT];
> 	R2_outside_GF_C		= new double * [nKT];
> 	R2_sidelong_GF_C	= new double * [nKT];
> 	R2_outlong_GF_C		= new double * [nKT];
> 
> 	R2_side_GF_S		= new double * [nKT];
> 	R2_out_GF_S		= new double * [nKT];
> 	R2_long_GF_S		= new double * [nKT];
> 	R2_outside_GF_S		= new double * [nKT];
> 	R2_sidelong_GF_S	= new double * [nKT];
> 	R2_outlong_GF_S		= new double * [nKT];
> 
> 	R2_side_err		= new double * [n_pT_pts];
> 	R2_out_err			= new double * [n_pT_pts];
> 	R2_long_err		= new double * [n_pT_pts];
> 	R2_outside_err		= new double * [n_pT_pts];
> 	R2_sidelong_err		= new double * [n_pT_pts];
> 	R2_outlong_err		= new double * [n_pT_pts];
> 
> 	R2_side_QM			= new double * [n_pT_pts];
> 	R2_out_QM			= new double * [n_pT_pts];
> 	R2_long_QM			= new double * [n_pT_pts];
> 	R2_outside_QM		= new double * [n_pT_pts];
> 	R2_sidelong_QM		= new double * [n_pT_pts];
> 	R2_outlong_QM		= new double * [n_pT_pts];
> 
> 	R2_side_QM_C		= new double * [nKT];
> 	R2_out_QM_C		= new double * [nKT];
> 	R2_long_QM_C		= new double * [nKT];
> 	R2_outside_QM_C		= new double * [nKT];
> 	R2_sidelong_QM_C	= new double * [nKT];
> 	R2_outlong_QM_C		= new double * [nKT];
> 
> 	R2_side_QM_S		= new double * [nKT];
> 	R2_out_QM_S		= new double * [nKT];
> 	R2_long_QM_S		= new double * [nKT];
> 	R2_outside_QM_S		= new double * [nKT];
> 	R2_sidelong_QM_S	= new double * [nKT];
> 	R2_outlong_QM_S		= new double * [nKT];
484,485c639,640
< 	lambda_Correl = new double * [n_pT_pts];
< 	lambda_Correl_err = new double * [n_pT_pts];
---
> 	lambda_Correl		= new double * [n_pT_pts];
> 	lambda_Correl_err	= new double * [n_pT_pts];
487c642
< 	lambda_QM = new double * [n_pT_pts];
---
> 	lambda_QM			= new double * [n_pT_pts];
491,510c646,665
< 		R2_side_GF[ipt] = new double [n_pphi_pts];
< 		R2_out_GF[ipt] = new double [n_pphi_pts];
< 		R2_outside_GF[ipt] = new double [n_pphi_pts];
< 		R2_long_GF[ipt] = new double [n_pphi_pts];
< 		R2_sidelong_GF[ipt] = new double [n_pphi_pts];
< 		R2_outlong_GF[ipt] = new double [n_pphi_pts];
< 
< 		R2_side_QM[ipt] = new double [n_pphi_pts];
< 		R2_out_QM[ipt] = new double [n_pphi_pts];
< 		R2_outside_QM[ipt] = new double [n_pphi_pts];
< 		R2_long_QM[ipt] = new double [n_pphi_pts];
< 		R2_sidelong_QM[ipt] = new double [n_pphi_pts];
< 		R2_outlong_QM[ipt] = new double [n_pphi_pts];
< 
< 		R2_side_err[ipt] = new double [n_pphi_pts];
< 		R2_out_err[ipt] = new double [n_pphi_pts];
< 		R2_long_err[ipt] = new double [n_pphi_pts];
< 		R2_outside_err[ipt] = new double [n_pphi_pts];
< 		R2_sidelong_err[ipt] = new double [n_pphi_pts];
< 		R2_outlong_err[ipt] = new double [n_pphi_pts];
---
> 		R2_side_GF[ipt]			= new double [n_pphi_pts];
> 		R2_out_GF[ipt]			= new double [n_pphi_pts];
> 		R2_outside_GF[ipt]		= new double [n_pphi_pts];
> 		R2_long_GF[ipt]			= new double [n_pphi_pts];
> 		R2_sidelong_GF[ipt]	= new double [n_pphi_pts];
> 		R2_outlong_GF[ipt]		= new double [n_pphi_pts];
> 
> 		R2_side_QM[ipt]			= new double [n_pphi_pts];
> 		R2_out_QM[ipt]			= new double [n_pphi_pts];
> 		R2_outside_QM[ipt]		= new double [n_pphi_pts];
> 		R2_long_QM[ipt]			= new double [n_pphi_pts];
> 		R2_sidelong_QM[ipt]	= new double [n_pphi_pts];
> 		R2_outlong_QM[ipt]		= new double [n_pphi_pts];
> 
> 		R2_side_err[ipt]		= new double [n_pphi_pts];
> 		R2_out_err[ipt]			= new double [n_pphi_pts];
> 		R2_long_err[ipt]		= new double [n_pphi_pts];
> 		R2_outside_err[ipt]	= new double [n_pphi_pts];
> 		R2_sidelong_err[ipt]	= new double [n_pphi_pts];
> 		R2_outlong_err[ipt]	= new double [n_pphi_pts];
512,513c667,668
< 		lambda_Correl[ipt] = new double [n_pphi_pts];
< 		lambda_Correl_err[ipt] = new double [n_pphi_pts];
---
> 		lambda_Correl[ipt]		= new double [n_pphi_pts];
> 		lambda_Correl_err[ipt]	= new double [n_pphi_pts];
515c670
< 		lambda_QM[ipt] = new double [n_pphi_pts];
---
> 		lambda_QM[ipt]			= new double [n_pphi_pts];
519,531c674,686
< 			R2_side_GF[ipt][ipphi] = 0.;
< 			R2_out_GF[ipt][ipphi] = 0.;
< 			R2_long_GF[ipt][ipphi] = 0.;
< 			R2_outside_GF[ipt][ipphi] = 0.;
< 			R2_sidelong_GF[ipt][ipphi] = 0.;
< 			R2_outlong_GF[ipt][ipphi] = 0.;
< 
< 			R2_side_err[ipt][ipphi] = 0.;
< 			R2_out_err[ipt][ipphi] = 0.;
< 			R2_long_err[ipt][ipphi] = 0.;
< 			R2_outside_err[ipt][ipphi] = 0.;
< 			R2_sidelong_err[ipt][ipphi] = 0.;
< 			R2_outlong_err[ipt][ipphi] = 0.;
---
> 			R2_side_GF[ipt][ipphi]			= 0.0;
> 			R2_out_GF[ipt][ipphi]			= 0.0;
> 			R2_long_GF[ipt][ipphi]			= 0.0;
> 			R2_outside_GF[ipt][ipphi]		= 0.0;
> 			R2_sidelong_GF[ipt][ipphi]		= 0.0;
> 			R2_outlong_GF[ipt][ipphi]		= 0.0;
> 
> 			R2_side_err[ipt][ipphi]			= 0.0;
> 			R2_out_err[ipt][ipphi]			= 0.0;
> 			R2_long_err[ipt][ipphi]			= 0.0;
> 			R2_outside_err[ipt][ipphi]		= 0.0;
> 			R2_sidelong_err[ipt][ipphi]	= 0.0;
> 			R2_outlong_err[ipt][ipphi]		= 0.0;
533,534c688,689
< 			lambda_Correl[ipt][ipphi] = 0.0;
< 			lambda_Correl_err[ipt][ipphi] = 0.0;
---
> 			lambda_Correl[ipt][ipphi]		= 0.0;
> 			lambda_Correl_err[ipt][ipphi]	= 0.0;
540,566c695,721
< 		R2_side_GF_C[iKT] = new double [n_order];
< 		R2_out_GF_C[iKT] = new double [n_order];
< 		R2_outside_GF_C[iKT] = new double [n_order];
< 		R2_long_GF_C[iKT] = new double [n_order];
< 		R2_sidelong_GF_C[iKT] = new double [n_order];
< 		R2_outlong_GF_C[iKT] = new double [n_order];
< 
< 		R2_side_GF_S[iKT] = new double [n_order];
< 		R2_out_GF_S[iKT] = new double [n_order];
< 		R2_outside_GF_S[iKT] = new double [n_order];
< 		R2_long_GF_S[iKT] = new double [n_order];
< 		R2_sidelong_GF_S[iKT] = new double [n_order];
< 		R2_outlong_GF_S[iKT] = new double [n_order];
< 
< 		R2_side_QM_C[iKT] = new double [n_order];
< 		R2_out_QM_C[iKT] = new double [n_order];
< 		R2_outside_QM_C[iKT] = new double [n_order];
< 		R2_long_QM_C[iKT] = new double [n_order];
< 		R2_sidelong_QM_C[iKT] = new double [n_order];
< 		R2_outlong_QM_C[iKT] = new double [n_order];
< 
< 		R2_side_QM_S[iKT] = new double [n_order];
< 		R2_out_QM_S[iKT] = new double [n_order];
< 		R2_outside_QM_S[iKT] = new double [n_order];
< 		R2_long_QM_S[iKT] = new double [n_order];
< 		R2_sidelong_QM_S[iKT] = new double [n_order];
< 		R2_outlong_QM_S[iKT] = new double [n_order];
---
> 		R2_side_GF_C[iKT]		= new double [n_order];
> 		R2_out_GF_C[iKT]		= new double [n_order];
> 		R2_outside_GF_C[iKT]	= new double [n_order];
> 		R2_long_GF_C[iKT]		= new double [n_order];
> 		R2_sidelong_GF_C[iKT]	= new double [n_order];
> 		R2_outlong_GF_C[iKT]	= new double [n_order];
> 
> 		R2_side_GF_S[iKT]		= new double [n_order];
> 		R2_out_GF_S[iKT]		= new double [n_order];
> 		R2_outside_GF_S[iKT]	= new double [n_order];
> 		R2_long_GF_S[iKT]		= new double [n_order];
> 		R2_sidelong_GF_S[iKT]	= new double [n_order];
> 		R2_outlong_GF_S[iKT]	= new double [n_order];
> 
> 		R2_side_QM_C[iKT]		= new double [n_order];
> 		R2_out_QM_C[iKT]		= new double [n_order];
> 		R2_outside_QM_C[iKT]	= new double [n_order];
> 		R2_long_QM_C[iKT]		= new double [n_order];
> 		R2_sidelong_QM_C[iKT]	= new double [n_order];
> 		R2_outlong_QM_C[iKT]	= new double [n_order];
> 
> 		R2_side_QM_S[iKT]		= new double [n_order];
> 		R2_out_QM_S[iKT]		= new double [n_order];
> 		R2_outside_QM_S[iKT]	= new double [n_order];
> 		R2_long_QM_S[iKT]		= new double [n_order];
> 		R2_sidelong_QM_S[iKT]	= new double [n_order];
> 		R2_outlong_QM_S[iKT]	= new double [n_order];
570,596c725,751
< 			R2_side_GF_C[iKT][in] = 0.;
< 			R2_out_GF_C[iKT][in] = 0.;
< 			R2_long_GF_C[iKT][in] = 0.;
< 			R2_outside_GF_C[iKT][in] = 0.;
< 			R2_sidelong_GF_C[iKT][in] = 0.;
< 			R2_outlong_GF_C[iKT][in] = 0.;
< 
< 			R2_side_GF_S[iKT][in] = 0.;
< 			R2_out_GF_S[iKT][in] = 0.;
< 			R2_long_GF_S[iKT][in] = 0.;
< 			R2_outside_GF_S[iKT][in] = 0.;
< 			R2_sidelong_GF_S[iKT][in] = 0.;
< 			R2_outlong_GF_S[iKT][in] = 0.;
< 
< 			R2_side_QM_C[iKT][in] = 0.;
< 			R2_out_QM_C[iKT][in] = 0.;
< 			R2_long_QM_C[iKT][in] = 0.;
< 			R2_outside_QM_C[iKT][in] = 0.;
< 			R2_sidelong_QM_C[iKT][in] = 0.;
< 			R2_outlong_QM_C[iKT][in] = 0.;
< 
< 			R2_side_QM_S[iKT][in] = 0.;
< 			R2_out_QM_S[iKT][in] = 0.;
< 			R2_long_QM_S[iKT][in] = 0.;
< 			R2_outside_QM_S[iKT][in] = 0.;
< 			R2_sidelong_QM_S[iKT][in] = 0.;
< 			R2_outlong_QM_S[iKT][in] = 0.;
---
> 			R2_side_GF_C[iKT][in]		= 0.;
> 			R2_out_GF_C[iKT][in]		= 0.;
> 			R2_long_GF_C[iKT][in]		= 0.;
> 			R2_outside_GF_C[iKT][in]	= 0.;
> 			R2_sidelong_GF_C[iKT][in]	= 0.;
> 			R2_outlong_GF_C[iKT][in]	= 0.;
> 
> 			R2_side_GF_S[iKT][in]		= 0.;
> 			R2_out_GF_S[iKT][in]		= 0.;
> 			R2_long_GF_S[iKT][in]		= 0.;
> 			R2_outside_GF_S[iKT][in]	= 0.;
> 			R2_sidelong_GF_S[iKT][in]	= 0.;
> 			R2_outlong_GF_S[iKT][in]	= 0.;
> 
> 			R2_side_QM_C[iKT][in]		= 0.;
> 			R2_out_QM_C[iKT][in]		= 0.;
> 			R2_long_QM_C[iKT][in]		= 0.;
> 			R2_outside_QM_C[iKT][in]	= 0.;
> 			R2_sidelong_QM_C[iKT][in]	= 0.;
> 			R2_outlong_QM_C[iKT][in]	= 0.;
> 
> 			R2_side_QM_S[iKT][in]		= 0.;
> 			R2_out_QM_S[iKT][in]		= 0.;
> 			R2_long_QM_S[iKT][in]		= 0.;
> 			R2_outside_QM_S[iKT][in]	= 0.;
> 			R2_sidelong_QM_S[iKT][in]	= 0.;
> 			R2_outlong_QM_S[iKT][in]	= 0.;
620,621d774
< 	//oscx = new double [FO_length * qxnpts * 2];
< 	//oscy = new double [FO_length * qynpts * 2];
627,633c780,786
< 		FO_surf * surf = &FOsurf_ptr[isurf];
< 		oscx[isurf] = new double [qxnpts * 2];
< 		oscy[isurf] = new double [qynpts * 2];
< 
< 		double tau = surf->tau;
< 		double xpt = surf->xpt;
< 		double ypt = surf->ypt;
---
> 		FO_surf * surf	= &FOsurf_ptr[isurf];
> 		oscx[isurf]	= new double [qxnpts * 2];
> 		oscy[isurf]	= new double [qynpts * 2];
> 
> 		double tau		= surf->tau;
> 		double xpt		= surf->xpt;
> 		double ypt		= surf->ypt;
637,638d789
< 			//oscx[(isurf * qxnpts + iqx) * 2 + 0] = cos(hbarCm1*qx_pts[iqx]*xpt);
< 			//oscx[(isurf * qxnpts + iqx) * 2 + 1] = sin(hbarCm1*qx_pts[iqx]*xpt);
645,646d795
< 			//oscy[(isurf * qynpts + iqy) * 2 + 0] = cos(hbarCm1*qy_pts[iqy]*ypt);
< 			//oscy[(isurf * qynpts + iqy) * 2 + 1] = sin(hbarCm1*qy_pts[iqy]*ypt);
708,711c857,860
< 	CFvals = new double **** [n_pT_pts];
< 	thermalCFvals = new double **** [n_pT_pts];
< 	crosstermCFvals = new double **** [n_pT_pts];
< 	resonancesCFvals = new double **** [n_pT_pts];
---
> 	CFvals				= new double **** [n_pT_pts];
> 	thermalCFvals		= new double **** [n_pT_pts];
> 	crosstermCFvals		= new double **** [n_pT_pts];
> 	resonancesCFvals	= new double **** [n_pT_pts];
714,717c863,866
< 		CFvals[ipT] = new double *** [n_pphi_pts];
< 		thermalCFvals[ipT] = new double *** [n_pphi_pts];
< 		crosstermCFvals[ipT] = new double *** [n_pphi_pts];
< 		resonancesCFvals[ipT] = new double *** [n_pphi_pts];
---
> 		CFvals[ipT]			= new double *** [n_pphi_pts];
> 		thermalCFvals[ipT]		= new double *** [n_pphi_pts];
> 		crosstermCFvals[ipT]	= new double *** [n_pphi_pts];
> 		resonancesCFvals[ipT]	= new double *** [n_pphi_pts];
720,723c869,872
< 			CFvals[ipT][ipphi] = new double ** [qxnpts];
< 			thermalCFvals[ipT][ipphi] = new double ** [qxnpts];
< 			crosstermCFvals[ipT][ipphi] = new double ** [qxnpts];
< 			resonancesCFvals[ipT][ipphi] = new double ** [qxnpts];
---
> 			CFvals[ipT][ipphi]				= new double ** [qxnpts];
> 			thermalCFvals[ipT][ipphi]		= new double ** [qxnpts];
> 			crosstermCFvals[ipT][ipphi]	= new double ** [qxnpts];
> 			resonancesCFvals[ipT][ipphi]	= new double ** [qxnpts];
726,729c875,878
< 				CFvals[ipT][ipphi][iqx] = new double * [qynpts];
< 				thermalCFvals[ipT][ipphi][iqx] = new double * [qynpts];
< 				crosstermCFvals[ipT][ipphi][iqx] = new double * [qynpts];
< 				resonancesCFvals[ipT][ipphi][iqx] = new double * [qynpts];
---
> 				CFvals[ipT][ipphi][iqx]				= new double * [qynpts];
> 				thermalCFvals[ipT][ipphi][iqx]		= new double * [qynpts];
> 				crosstermCFvals[ipT][ipphi][iqx]	= new double * [qynpts];
> 				resonancesCFvals[ipT][ipphi][iqx]	= new double * [qynpts];
732,735c881,888
< 					CFvals[ipT][ipphi][iqx][iqy] = new double [qznpts];
< 					thermalCFvals[ipT][ipphi][iqx][iqy] = new double [qznpts];
< 					crosstermCFvals[ipT][ipphi][iqx][iqy] = new double [qznpts];
< 					resonancesCFvals[ipT][ipphi][iqx][iqy] = new double [qznpts];
---
> 					CFvals[ipT][ipphi][iqx][iqy]
> 						= new double [qznpts];
> 					thermalCFvals[ipT][ipphi][iqx][iqy]
> 						= new double [qznpts];
> 					crosstermCFvals[ipT][ipphi][iqx][iqy]
> 						= new double [qznpts];
> 					resonancesCFvals[ipT][ipphi][iqx][iqy]
> 						= new double [qznpts];
738,740c891,893
< 						CFvals[ipT][ipphi][iqx][iqy][iqz] = 0.0;
< 						thermalCFvals[ipT][ipphi][iqx][iqy][iqz] = 0.0;
< 						crosstermCFvals[ipT][ipphi][iqx][iqy][iqz] = 0.0;
---
> 						CFvals[ipT][ipphi][iqx][iqy][iqz]			= 0.0;
> 						thermalCFvals[ipT][ipphi][iqx][iqy][iqz]	= 0.0;
> 						crosstermCFvals[ipT][ipphi][iqx][iqy][iqz]	= 0.0;
791c944,956
< 	if (VERBOSE > 2) *global_out_stream_ptr << "Reallocating memory for decay channel information..." << endl;
---
> 	if (VERBOSE > 2)
> 		*out << "Reallocating memory for decay channel information..."
> 				<< endl;
> 
> 	const int n_spacetime_dims = 4;
> 
> 	VEC_n2_v_factor			= new double [n_v_pts];
> 	VEC_n2_P_Y				= new double [n_v_pts];
> 	VEC_n2_zeta_factor		= new double [n_v_pts * n_zeta_pts];
> 	VEC_n2_PPhi_tilde		= new double [n_v_pts * n_zeta_pts];
> 	VEC_n2_PPhi_tildeFLIP	= new double [n_v_pts * n_zeta_pts];
> 	VEC_n2_PT				= new double [n_v_pts * n_zeta_pts];
> 	VEC_n2_Ppm				= new double * [n_v_pts * n_zeta_pts * 2];
793,799d957
< 	VEC_n2_v_factor = new double [n_v_pts];
< 	VEC_n2_P_Y = new double [n_v_pts];
< 	VEC_n2_zeta_factor = new double [n_v_pts * n_zeta_pts];
< 	VEC_n2_PPhi_tilde = new double [n_v_pts * n_zeta_pts];
< 	VEC_n2_PPhi_tildeFLIP = new double [n_v_pts * n_zeta_pts];
< 	VEC_n2_PT = new double [n_v_pts * n_zeta_pts];
< 	VEC_n2_Ppm = new double * [n_v_pts * n_zeta_pts * 2];
801c959,971
< 		VEC_n2_Ppm[ii] = new double [4];	//four corresponds to space-time components
---
> 		VEC_n2_Ppm[ii]		= new double [n_spacetime_dims];
> 
> 	s_pts					= new double [n_s_pts];
> 	s_wts					= new double [n_s_pts];
> 	VEC_n3_g_s				= new double [n_s_pts];
> 	VEC_n3_s_factor			= new double [n_s_pts];
> 	VEC_n3_v_factor			= new double [n_s_pts * n_v_pts];
> 	VEC_n3_zeta_factor		= new double [n_s_pts * n_v_pts * n_zeta_pts];
> 	VEC_n3_P_Y				= new double [n_s_pts * n_v_pts];
> 	VEC_n3_PPhi_tilde		= new double [n_s_pts * n_v_pts * n_zeta_pts];
> 	VEC_n3_PPhi_tildeFLIP	= new double [n_s_pts * n_v_pts * n_zeta_pts];
> 	VEC_n3_PT				= new double [n_s_pts * n_v_pts * n_zeta_pts];
> 	VEC_n3_Ppm				= new double * [n_s_pts * n_v_pts * n_zeta_pts * 2];
803,813d972
< 	s_pts = new double [n_s_pts];
< 	s_wts = new double [n_s_pts];
< 	VEC_n3_g_s = new double [n_s_pts];
< 	VEC_n3_s_factor = new double [n_s_pts];
< 	VEC_n3_v_factor = new double [n_s_pts * n_v_pts];
< 	VEC_n3_zeta_factor = new double [n_s_pts * n_v_pts * n_zeta_pts];
< 	VEC_n3_P_Y = new double [n_s_pts * n_v_pts];
< 	VEC_n3_PPhi_tilde = new double [n_s_pts * n_v_pts * n_zeta_pts];
< 	VEC_n3_PPhi_tildeFLIP = new double [n_s_pts * n_v_pts * n_zeta_pts];
< 	VEC_n3_PT = new double [n_s_pts * n_v_pts * n_zeta_pts];
< 	VEC_n3_Ppm = new double * [n_s_pts * n_v_pts * n_zeta_pts * 2];
815c974
< 		VEC_n3_Ppm[ii] = new double [4];	//four corresponds to space-time components
---
> 		VEC_n3_Ppm[ii]		= new double [n_spacetime_dims];
817c976,978
< 	if (VERBOSE > 2) *global_out_stream_ptr << "Reallocated memory for decay channel information." << endl;
---
> 	if (VERBOSE > 2)
> 		*out << "Reallocated memory for decay channel information."
> 				<< endl;
824c985,987
< 	if (VERBOSE > 2) *global_out_stream_ptr << "Deleting memory for decay channel information..." << endl;
---
> 	if (VERBOSE > 2)
> 		*out << "Deleting memory for decay channel information..."
> 				<< endl;
851c1014,1016
< 	if (VERBOSE > 2) *global_out_stream_ptr << "Deleted memory for decay channel information." << endl;
---
> 	if (VERBOSE > 2)
> 		*out << "Deleted memory for decay channel information."
> 				<< endl;
881,884c1046,1049
< 	qt_pts = new double [qtnpts];
< 	qx_pts = new double [qxnpts];
< 	qy_pts = new double [qynpts];
< 	qz_pts = new double [qznpts];
---
> 	qt_pts				= new double [qtnpts];
> 	qx_pts				= new double [qxnpts];
> 	qy_pts				= new double [qynpts];
> 	qz_pts				= new double [qznpts];
889,899c1054,1070
< 	double mtarget = all_particles[target_particle_id].mass;
< 	double qxmax = abs(init_qx);
< 	double qymax = abs(init_qy);
< 	qx_max = abs(init_qx);
< 	qy_max = abs(init_qy);
< 	qz_max = abs(init_qz);
< 
< 	double qxymax = sqrt(qxmax*qxmax+qymax*qymax);
< 	double xi2 = mtarget*mtarget + SP_pT_max*SP_pT_max + 0.25*qxymax*qxymax;	//pretend that Kphi == 0, qx == qo and qs == ql == 0, to maximize qtmax
< 	//qtmax = sqrt(xi2 + SP_pT_max*qxymax) - sqrt(xi2 - SP_pT_max*qxymax) + 1.e-10; //THIS IS THE INCORRECT VERSION - ONLY NEEDED FOR COMPARISONS WITH PREVIOUS CODE VERSIONS!!!
< 	qtmax = max( qxymax, qz_max );				//just choose the biggest value (THIS IS THE CORRECT VERSION!!!!!)
---
> 	double mtarget		= all_particles[target_particle_id].mass;
> 	double qxmax		= abs(init_qx);
> 	double qymax		= abs(init_qy);
> 	qx_max				= abs(init_qx);
> 	qy_max				= abs(init_qy);
> 	qz_max				= abs(init_qz);
> 
> 	double qxymax		= sqrt(qxmax*qxmax+qymax*qymax);
> 	//pretend that Kphi == 0, qx == qo and qs == ql == 0, to maximize qtmax
> 	double xi2			= mtarget*mtarget
> 							+ SP_pT_max*SP_pT_max
> 							+ 0.25*qxymax*qxymax;
> 	//THIS IS THE INCORRECT VERSION
> 	// - ONLY NEEDED FOR COMPARISONS WITH PREVIOUS CODE VERSIONS!!!
> 	//qtmax = sqrt(xi2 + SP_pT_max*qxymax)
> 	//			- sqrt(xi2 - SP_pT_max*qxymax)
> 	//			+ 1.e-10;
901,902c1072,1073
< 	//for bug-checking
< 	//qtmax = 0.2;
---
> 	//just choose the biggest value (THIS IS THE CORRECT VERSION!!!!!)
> 	qtmax = max( qxymax, qz_max );
905d1075
< 	//Fill_out_pts(qt_pts, qtnpts, sqrt(1.1*init_qz*init_qz), 0);
915,924d1084
< 	/*for (int iqt = 0; iqt < qtnpts; ++iqt)
< 	for (int iqx = 0; iqx < qxnpts; ++iqx)
< 	for (int iqy = 0; iqy < qynpts; ++iqy)
< 	for (int iqz = 0; iqz < qznpts; ++iqz)
< 		cout << "CHECK q grid points: " << qt_pts[iqt] << "   " << qx_pts[iqx] << "   " << qy_pts[iqy] << "   " << qz_pts[iqz] << endl;
< 
< 	if (1) exit (8);*/
< 
< 	//cout << "Output iq*0 = " << iqt0 << "	  " << iqx0 << "   " << iqy0 << "   " << iqz0 << endl;
< 
928c1088,1090
< void CorrelationFunction::Fill_out_pts(double * pointsarray, int numpoints, double max_val, int spacing_type)
---
> void CorrelationFunction::Fill_out_pts(
> 		double * pointsarray, int numpoints,
> 		double max_val, int spacing_type)
940c1102,1104
< 				pointsarray[iqd] = -max_val + (double)iqd * 2.*max_val / double(numpoints - 1+1e-100);
---
> 				pointsarray[iqd]
> 					= - max_val + (double)iqd * 2.*max_val
> 									/ double(numpoints - 1+1e-100);
948c1112,1114
< 				pointsarray[iqd] = local_scale * cos( M_PI*(2.*(iqd+1.) - 1.) / (2.*numpoints) );
---
> 				pointsarray[iqd]
> 					= local_scale * cos( M_PI * ( 2.*(iqd+1.) - 1. )
> 											/ (2.*numpoints) );
953c1119
< 			const int n = (numpoints + 1) / 2;
---
> 			const int n	= (numpoints + 1) / 2;
955,959c1121,1125
< 			double z1[n], z2[n-1];
< 			double tmptan = tan(M_PI / (4.0*n));
< 			double a1 = -max_val, b1 = max_val*tmptan*tmptan;	//guarantee that middle point is 0
< 			double a2 = -max_val*tmptan*tmptan, b2 = max_val;	//guarantee that middle point is 0
< 			double hw1 = 0.5 * (b1 - a1), hw2 = 0.5 * (b2 - a2);
---
> 			double tmptan	= tan(M_PI / (4.0*n));
> 			//choose definitions to guarantee that middle point is 0
> 			double a1		= -max_val, b1 = max_val*tmptan*tmptan;
> 			double a2		= -max_val*tmptan*tmptan, b2 = max_val;
> 			double hw1		= 0.5 * (b1 - a1), hw2 = 0.5 * (b2 - a2);
960a1127
> 			double z1[n], z2[n-1];
980c1147,1149
< 				pointsarray[iqd] = -max_val * tmptan * cot(M_PI*(2.0*ii-1.0)/(2.0*numpoints));
---
> 				pointsarray[iqd]
> 					= - max_val * tmptan
> 						* cot(M_PI*(2.0*ii-1.0)/(2.0*numpoints));
986c1155
< 			const int n = (numpoints + 1) / 2;
---
> 			const int n	= (numpoints + 1) / 2;
988c1157
< 			double tmpsin = sin(3.0*M_PI / (4.0*n));
---
> 			double tmpsin	= sin(3.0*M_PI / (4.0*n));
990,991c1159,1160
< 			double tmpcos2 = cos(M_PI / (2.0*n));
< 			double tmpcos3 = cos(3.0*M_PI / (2.0*n));
---
> 			double tmpcos2	= cos(M_PI / (2.0*n));
> 			double tmpcos3	= cos(3.0*M_PI / (2.0*n));
995,999c1164,1170
< 				double ii = iqd + 1.0;
< 				double numerator = 2.0 * max_val * tmpsin * tmpsin
< 									* ( cos(M_PI*(2.0*ii-1.0)/(2.0*n)) + tmpcos2 );
< 				double denominator = ( cos(M_PI*(2.0*ii-1.0)/(2.0*n)) - 1.0 ) * (tmpcos2 + tmpcos3);
< 				pointsarray[iqd] = numerator / denominator;
---
> 				double ii			= iqd + 1.0;
> 				double numerator	= 2.0 * max_val * tmpsin * tmpsin
> 										* ( cos(M_PI*(2.0*ii-1.0)/(2.0*n))
> 											+ tmpcos2 );
> 				double denominator	= ( cos(M_PI*(2.0*ii-1.0)/(2.0*n)) - 1.0 )
> 										* (tmpcos2 + tmpcos3);
> 				pointsarray[iqd]	= numerator / denominator;
1001c1172,1173
< 				pointsarray[numpoints-iqd-1] = -pointsarray[iqd];
---
> 				pointsarray[numpoints-iqd-1]
> 									= -pointsarray[iqd];
1010,1058c1182,1193
< inline int norm (vector<int> v) { int norm2 = 0; for (size_t iv = 0; iv < v.size(); ++iv) norm2+=v[iv]*v[iv]; return (norm2); }
< 
< inline bool qpt_comparator (vector<int> i, vector<int> j) { return (norm(i) < norm(j)); }
< 
< void CorrelationFunction::Set_sorted_q_pts_list()
< {
< 	vector<int> tmp (4);
< 
< 	//sort through all q-points with qt <= 0 by proximity to origin in q-space
< 	//allows to do largest CF values first
< 	for (int iqt = 0; iqt < (qtnpts / 2) + 1; ++iqt)
< 	for (int iqx = 0; iqx < qxnpts; ++iqx)
< 	for (int iqy = 0; iqy < qynpts; ++iqy)
< 	for (int iqz = 0; iqz < qznpts; ++iqz)
< 	{
< 		tmp[0] = iqt - iqt0;
< 		tmp[1] = iqx - iqx0;
< 		tmp[2] = iqy - iqy0;
< 		tmp[3] = iqz - iqz0;
< 
< 		sorted_q_pts_list.push_back(tmp);
< 	}
< 
< 	sort(sorted_q_pts_list.begin(), sorted_q_pts_list.end(), qpt_comparator);
< 
< 	//cout << "Checking sorting of q-points: " << endl;
< 	for (size_t iq = 0; iq < sorted_q_pts_list.size(); ++iq)
< 	{
< 		sorted_q_pts_list[iq][0] += iqt0;
< 		sorted_q_pts_list[iq][1] += iqx0;
< 		sorted_q_pts_list[iq][2] += iqy0;
< 		sorted_q_pts_list[iq][3] += iqz0;
< 
< 		//cout << "   --> iq = " << iq << ": ";
< 		//for (size_t iqmu = 0; iqmu < 4; ++iqmu)
< 		//	cout << sorted_q_pts_list[iq][iqmu] << "   ";
< 		//cout << endl;
< 	}
< 
< 	return;
< }
< 
< // returns points in q-space for computing weighted spectra grid corresponding to to given q and K choices
< // weighted spectra grid thus needs to be interpolated at point returned in qgridpts
< void CorrelationFunction::Get_q_points(double q1, double q2, double q3, double pT, double pphi, double * qgridpts)
< {
< 	double mtarget = all_particles[target_particle_id].mass;
< 	double xi2 = mtarget*mtarget + pT*pT + 0.25*(q1*q1 + q2*q2 + q3*q3);
< 	double ckp = cos(pphi), skp = sin(pphi);
---
> // returns points in q-space for computing weighted spectra grid
> // corresponding to to given q and K choices
> // weighted spectra grid thus needs to be interpolated at the point
> // which isreturned in qgridpts
> void CorrelationFunction::Get_q_points(
> 		double q1, double q2, double q3,
> 		double pT, double pphi, double * qgridpts)
> {
> 	double mtarget	= all_particles[target_particle_id].mass;
> 	double xi2		= mtarget*mtarget + pT*pT + 0.25*(q1*q1 + q2*q2 + q3*q3);
> 	double ckp		= cos(pphi);
> 	double skp		= sin(pphi);
1060c1195
< 	double qo = ckp * q1 + skp * q2;
---
> 	double qo		= ckp * q1 + skp * q2;
1063,1066c1198,1201
< 	qgridpts[0] = sqrt(xi2 + qo*pT) - sqrt(xi2 - qo*pT);	//set qt component
< 	qgridpts[1] = q1;										//set qx component
< 	qgridpts[2] = q2;										//set qy component
< 	qgridpts[3] = q3;										//set qz component, since qz = ql
---
> 	qgridpts[0]	= sqrt(xi2 + qo*pT) - sqrt(xi2 - qo*pT);	//qt
> 	qgridpts[1]	= q1;										//qx
> 	qgridpts[2]	= q2;										//qy
> 	qgridpts[3]	= q3;										//qz
1073,1074c1208,1209
<   ifstream ifile(filename);
<   return ifile;
---
> 	ifstream ifile(filename);
> 	return ifile;
1094,1095c1229,1230
< 	FOsurf_ptr = FOsurf_ptr_in;
< 	FO_length = FO_length_in;
---
> 	FOsurf_ptr	= FOsurf_ptr_in;
> 	FO_length	= FO_length_in;
1101c1236,1238
< 	Reset_FOcells_array();	//set everything to -1; ensures that all cells get set correctly
---
> 
> 	//initialize to -1; ensures that all cells get set correctly
> 	Reset_FOcells_array();
1106c1243,1244
< void CorrelationFunction::Get_current_decay_string(int dc_idx, string * decay_string)
---
> void CorrelationFunction::Get_current_decay_string(
> 		int dc_idx, string * decay_string)
1108c1246,1247
< 	// N.B. - dc_idx == 0 is thermal pion(+)s in calling loop, dc_idx > 0 gives resonance decays
---
> 	// N.B. - dc_idx == 0 is thermal pion(+)s in calling loop,
> 	// dc_idx > 0 gives resonance decays
1110c1249,1253
< 	*decay_string = decay_channels[dc_idx - 1].resonance_name + " --->> ";
---
> 	decay_info this_decay = decay_channels[dc_idx - 1];
> 
> 	// initialize decay string
> 	*decay_string = this_decay.resonance_name + " --->> ";
> 
1112,1115c1255,1263
< 	for (int decay_part_idx = 0; decay_part_idx < decay_channels[dc_idx - 1].nbody; decay_part_idx++)
< 	{
< 		temp_monval = decay_channels[dc_idx - 1].resonance_decay_monvals[decay_part_idx];
< 		if (VERBOSE > 0) *global_out_stream_ptr << "Get_current_decay_string(): temp_monval = " << temp_monval << endl;
---
> 	for (int decay_part_idx = 0;
> 			decay_part_idx < this_decay.nbody;
> 			decay_part_idx++)
> 	{
> 		temp_monval
> 			= this_decay.resonance_decay_monvals[decay_part_idx];
> 		if (VERBOSE > 3)
> 			*out << "Get_current_decay_string(): temp_monval = "
> 					<< temp_monval << endl;
1120,1122c1268,1272
< 			tempID = lookup_particle_id_from_monval(all_particles, Nparticle, temp_monval);
< 			*decay_string += all_particles[tempID].name;
< 			if (decay_part_idx < decay_channels[dc_idx - 1].nbody - 1) *decay_string += " + ";
---
> 			tempID			= lookup_particle_id_from_monval(
> 								all_particles, Nparticle, temp_monval);
> 			*decay_string  += all_particles[tempID].name;
> 			if (decay_part_idx < this_decay.nbody - 1)
> 				*decay_string += " + ";
1133,1134c1283,1285
< for (int i = 0; i < (int)chosen_resonances.size(); ++i)
< 	cout << chosen_resonances[i] << "   " << all_particles[chosen_resonances[i]].name << endl;
---
> 	//for (int i = 0; i < (int)chosen_resonances.size(); ++i)
> 	//	cout << chosen_resonances[i] << "   "
> 	//			<< all_particles[chosen_resonances[i]].name << endl;
1136c1287
< 	// then re-populate it
---
> 	// then re-populate the list
1137a1289,1291
> 
> 	// no daughters to worry about
> 	// if parent resonance is actually stable
1139c1293,1295
< 		return (0);									// no daughters to worry about if parent resonance is actually stable
---
> 		return (0);
> 
> 	// otherwise, see how many decays to consider
1141c1297,1299
< 	for (int k = 0; k < number_of_decays; k++)		// loop through decays for parent resonance
---
> 
> 	// loop through decays for parent resonance
> 	for (int k = 0; k < number_of_decays; k++)
1143,1144c1301,1305
< 		int nb = abs(parent.decays_Npart[k]);		// for each decay, nb is the number of daughter particles
< 		for (int l = 0; l < nb; l++)				// loop through each daughter particle
---
> 		// for each decay, nb is the number of daughter particles
> 		int nb = abs(parent.decays_Npart[k]);
> 
> 		// loop through each daughter particle
> 		for (int l = 0; l < nb; l++)
1146,1149c1307,1318
< 			int pid = lookup_particle_id_from_monval(all_particles, Nparticle, parent.decays_part[k][l]);
< cout << "Searching for " << pid << "   (" << all_particles[pid].name << ", " << all_particles[pid].effective_branchratio << ")"<< endl;
< 			if ( all_particles[pid].effective_branchratio >= 1.e-12 || pid == target_particle_id )
< 				daughter_resonance_indices.insert(pid);		// using a <set> object will automatically remove duplicates and keep pid's in a fixed order
---
> 			int pid = lookup_particle_id_from_monval(
> 						all_particles, Nparticle, parent.decays_part[k][l]);
> 			//cout << "Searching for " << pid
> 			//		<< "   (" << all_particles[pid].name
> 			//		<< ", " << all_particles[pid].effective_branchratio
> 			//		<< ")"<< endl;
> 
> 			// N.B. - using a <set> object will automatically remove duplicates
> 			//		  and keep pid's in a fixed order
> 			if ( all_particles[pid].effective_branchratio >= 1.e-12
> 					or pid == target_particle_id )
> 				daughter_resonance_indices.insert(pid);
1153,1156c1322,1334
< cout << endl << "Ended up with n_daughter = " << daughter_resonance_indices.size() << " for " << all_particles[parent_pid].name << " (" << parent_pid << ")" << endl;
< int i = 0;
< for (set<int>::iterator it = daughter_resonance_indices.begin(); it != daughter_resonance_indices.end(); ++it)
< 	cout << "parent = " << all_particles[parent_pid].name << ": " << i++ << "   " << *it << "   " << all_particles[*it].name << "	" << all_particles[*it].effective_branchratio << endl;
---
> 	//cout << endl << "Ended up with n_daughter = "
> 	//		<< daughter_resonance_indices.size() << " for "
> 	//		<< all_particles[parent_pid].name << " ("
> 	//		<< parent_pid << ")" << endl;
> 	//
> 	//int i = 0;
> 	//for ( set<int>::iterator it = daughter_resonance_indices.begin();
> 	//		it != daughter_resonance_indices.end();
> 	//		++it)
> 	//	cout << "parent = " << all_particles[parent_pid].name
> 	//			<< ": " << i++ << "   " << *it << "   "
> 	//			<< all_particles[*it].name << "	  "
> 	//			<< all_particles[*it].effective_branchratio << endl;
1177,1183c1355,1367
< 	// if pid is not one of the chosen_resonances, is not the target daughter (pion(+)), is not stable and has a non-zero effective branching ratio
< 	if (result < 0 && pid != particle_id && all_particles[pid].stable == 0 && all_particles[pid].effective_branchratio >= 1.e-12)
< 	{
< 		*global_out_stream_ptr << " *** lookup_resonance_idx_from_particle_id(): Particle_id = " << pid
< 					<< " (" << all_particles[pid].name <<") not found in chosen_resonances!" << endl
< 					<< " *** br = " << all_particles[pid].effective_branchratio << endl
< 					<< " *** Can only choose from: " << endl;
---
> 	// if pid is not one of the chosen_resonances,
> 	// is not the target daughter (pion(+)),
> 	// is not stable and has a non-zero effective branching ratio,
> 	// then return a warning message and crash
> 	if ( result < 0
> 			and pid != particle_id && all_particles[pid].stable == 0
> 			and all_particles[pid].effective_branchratio >= 1.e-12 )
> 	{
> 		*out << " *** lookup_resonance_idx_from_particle_id(): Particle_id = "
> 				<< pid << " (" << all_particles[pid].name
> 				<< ") not found in chosen_resonances!" << endl
> 				<< " *** br = " << all_particles[pid].effective_branchratio
> 				<< endl << " *** Can only choose from: " << endl;
1185,1186c1369,1371
< 			*global_out_stream_ptr << all_particles[chosen_resonances[ii]].name << ": pid = " << chosen_resonances[ii] << endl;
< 
---
> 			*out << all_particles[chosen_resonances[ii]].name
> 				<< ": pid = " << chosen_resonances[ii] << endl;
> 		exit(8);
1187a1373
> 
1193,1194c1379,1380
<     ssum_vec = new double [qspace_cs_slice_length];
<     vsum_vec = new double [qspace_cs_slice_length];
---
>     ssum_vec	= new double [qspace_cs_slice_length];
>     vsum_vec	= new double [qspace_cs_slice_length];
1196c1382
<     Csum_vec = new double [qspace_cs_slice_length];
---
>     Csum_vec	= new double [qspace_cs_slice_length];
1213c1399,1400
< void CorrelationFunction::Setup_current_daughters_dN_dypTdpTdphi_moments(int n_daughter)
---
> void CorrelationFunction
> 		::Setup_current_daughters_dN_dypTdpTdphi_moments(int n_daughter)
1215,1216c1402,1406
< 	const int giant_flat_array_size = n_pT_pts * n_pphi_pts * n_pY_pts * qxnpts * qynpts * ntrig;
< 	current_daughters_dN_dypTdpTdphi_moments = new double * [n_daughter];
---
> 	const int giant_flat_array_size
> 		= n_pT_pts * n_pphi_pts * n_pY_pts * qxnpts * qynpts * ntrig;
> 	current_daughters_dN_dypTdpTdphi_moments
> 		= new double * [n_daughter];
> 
1219c1409,1410
< 		current_daughters_dN_dypTdpTdphi_moments[id] = new double [giant_flat_array_size];
---
> 		current_daughters_dN_dypTdpTdphi_moments[id]
> 			= new double [giant_flat_array_size];
1222a1414
> 
1226c1418,1419
< void CorrelationFunction::Cleanup_current_daughters_dN_dypTdpTdphi_moments(int n_daughter)
---
> void CorrelationFunction
> 		::Cleanup_current_daughters_dN_dypTdpTdphi_moments(int n_daughter)
1237c1430,1431
< void CorrelationFunction::Load_decay_channel_info_nb2(int dc_idx, double K_T_local, double K_phi_local, double K_y_local)
---
> void CorrelationFunction::Load_decay_channel_info_nb2(
> 		int dc_idx, double K_T_local, double K_phi_local, double K_y_local)
1239,1250c1433,1449
< 	Mres = current_resonance_mass;
< 	Gamma = current_resonance_Gamma;
< 	one_by_Gamma_Mres = 1./(Gamma*Mres + 1.e-25);	//keeps calculation safe when Gamma == 0
< 	//N.B. - no need for hbarc, since this will only multiply something with GeV^2 units in the end
< 	mass = current_daughter_mass;
< 	br = current_resonance_direct_br;	//doesn't depend on target daughter particle, just parent resonance and decay channel
< 	m2 = current_resonance_decay_masses[0];
< 	m3 = current_resonance_decay_masses[1];
< 
< 	pT = K_T_local;
< 	current_K_phi = K_phi_local;
< 	p_y = K_y_local;
---
> 	Mres				= current_resonance_mass;
> 	Gamma				= current_resonance_Gamma;
> 	//keeps calculation safe when Gamma == 0
> 	one_by_Gamma_Mres	= 1./(Gamma*Mres + 1.e-25);
> 	//N.B. - no need for hbarc, since this will only
> 	//	 multiply something with GeV^2 units in the end
> 	mass				= current_daughter_mass;
> 	//doesn't depend on target daughter particle,
> 	// just parent resonance and decay channel
> 	br					= current_resonance_direct_br;
> 	m2					= current_resonance_decay_masses[0];
> 	m3					= current_resonance_decay_masses[1];
> 
> 	//bad choice of notation throughout...update to a new namespace!
> 	pT					= K_T_local;
> 	current_K_phi		= K_phi_local;
> 	p_y				= K_y_local;
1252c1451
< 	n_body = current_reso_nbody;
---
> 	n_body				= current_reso_nbody;
1254c1453,1454
< 	// some particles may decay to particles with more total mass than originally
---
> 	// some particles may decay to particles with
> 	// more total mass than originally
1258,1260c1458,1460
< 		Mres += 0.25 * current_resonance_Gamma;
< 		mass -= 0.5 * current_daughter_Gamma;
< 		m2 -= 0.5 * current_m2_Gamma;
---
> 		Mres	+= 0.25 * current_resonance_Gamma;
> 		mass	-= 0.5 * current_daughter_Gamma;
> 		m2		-= 0.5 * current_m2_Gamma;
1263c1463,1464
< 	mT = sqrt(mass*mass + pT*pT);
---
> 	// transverse mass
> 	mT					= sqrt(mass*mass + pT*pT);
1266,1271c1467,1476
< 	double s_loc = m2*m2;
< 	double pstar_loc = sqrt( ((Mres+mass)*(Mres+mass) - s_loc)*((Mres-mass)*(Mres-mass) - s_loc) )/(2.0*Mres);
< 	double g_s_loc = g(s_loc);	//for n_body == 2, doesn't actually use s_loc since result is just a factor * delta(...); just returns factor
< 	double Estar_loc = sqrt(mass*mass + pstar_loc*pstar_loc);
< 	double psBmT = pstar_loc / mT;
< 	double DeltaY_loc = log(psBmT + sqrt(1.+psBmT*psBmT));
---
> 	double s_loc		= m2*m2;
> 	double pstar_loc	= sqrt( ((Mres+mass)*(Mres+mass) - s_loc)
> 								*((Mres-mass)*(Mres-mass) - s_loc)
> 								)/(2.0*Mres);
> 	//for n_body == 2, doesn't actually use s_loc since the result
> 	// is just a factor * delta(...) and g(s) just returns factor
> 	double g_s_loc		= g(s_loc);
> 	double Estar_loc	= sqrt(mass*mass + pstar_loc*pstar_loc);
> 	double psBmT		= pstar_loc / mT;
> 	double DeltaY_loc	= log(psBmT + sqrt(1.+psBmT*psBmT));
1273c1478
< 	VEC_n2_s_factor = br/(4.*M_PI*pstar_loc);	//==g_s_loc
---
> 	VEC_n2_s_factor		= br/(4.*M_PI*pstar_loc);	//==g_s_loc
1277,1282c1482,1487
< 		double v_loc = v_pts[iv];
< 		double P_Y_loc = p_y + v_loc*DeltaY_loc;
< 		double mT_ch_P_Y_p_y = mT*cosh(v_loc*DeltaY_loc);
< 		double x2 = mT_ch_P_Y_p_y*mT_ch_P_Y_p_y - pT*pT;
< 		double MTbar_loc = Estar_loc*Mres*mT_ch_P_Y_p_y/x2;
< 		double DeltaMT_loc = Mres*pT*sqrt(Estar_loc*Estar_loc - x2)/x2;
---
> 		double v_loc			= v_pts[iv];
> 		double P_Y_loc			= p_y + v_loc*DeltaY_loc;
> 		double mT_ch_P_Y_p_y	= mT*cosh(v_loc*DeltaY_loc);
> 		double x2				= mT_ch_P_Y_p_y*mT_ch_P_Y_p_y - pT*pT;
> 		double MTbar_loc		= Estar_loc*Mres*mT_ch_P_Y_p_y/x2;
> 		double DeltaMT_loc		= Mres*pT*sqrt(Estar_loc*Estar_loc - x2)/x2;
1284,1285c1489,1490
< 		VEC_n2_P_Y[iv] = P_Y_loc;
< 		VEC_n2_v_factor[iv] = v_wts[iv]*DeltaY_loc/sqrt(x2);
---
> 		VEC_n2_P_Y[iv]			= P_Y_loc;
> 		VEC_n2_v_factor[iv]	= v_wts[iv]*DeltaY_loc/sqrt(x2);
1289,1300c1494,1523
< 			double zeta_loc = zeta_pts[izeta];
< 			double MT_loc = MTbar_loc + cos(zeta_loc)*DeltaMT_loc;
< 			double PT_loc = sqrt(MT_loc*MT_loc - Mres*Mres);
< 			double temp_cos_PPhi_tilde_loc = (mT*MT_loc*cosh(P_Y_loc-p_y) - Estar_loc*Mres)/(pT*PT_loc);
< 			//assume that PPhi_tilde is +ve in next step...
< 			double temp_sin_PPhi_tilde_loc = sqrt(1. - temp_cos_PPhi_tilde_loc*temp_cos_PPhi_tilde_loc);
< 			double PPhi_tilde_loc = place_in_range( atan2(temp_sin_PPhi_tilde_loc, temp_cos_PPhi_tilde_loc), Kphi_min, Kphi_max);
< 
< 			VEC_n2_zeta_factor[NB2_indexer(iv, izeta)] = zeta_wts[izeta]*MT_loc;
< 			VEC_n2_PPhi_tilde[NB2_indexer(iv, izeta)] = place_in_range( K_phi_local + PPhi_tilde_loc, Kphi_min, Kphi_max);
< 			VEC_n2_PPhi_tildeFLIP[NB2_indexer(iv, izeta)] = place_in_range( K_phi_local - PPhi_tilde_loc, Kphi_min, Kphi_max);
< 			VEC_n2_PT[NB2_indexer(iv, izeta)] = PT_loc;
---
> 			double zeta_loc
> 				= zeta_pts[izeta];
> 			double MT_loc
> 				= MTbar_loc + cos(zeta_loc)*DeltaMT_loc;
> 			double PT_loc
> 				= sqrt(MT_loc*MT_loc - Mres*Mres);
> 			double temp_cos_PPhi_tilde_loc
> 				= ( mT*MT_loc*cosh(P_Y_loc-p_y)
> 					- Estar_loc*Mres)/(pT*PT_loc);
> 			//assume that PPhi_tilde is positive in the next step...
> 			double temp_sin_PPhi_tilde_loc
> 				= sqrt(1. - temp_cos_PPhi_tilde_loc
> 							* temp_cos_PPhi_tilde_loc);
> 			double PPhi_tilde_loc
> 				= place_in_range( atan2(temp_sin_PPhi_tilde_loc,
> 									temp_cos_PPhi_tilde_loc),
> 									Kphi_min, Kphi_max);
> 
> 			VEC_n2_zeta_factor[NB2_indexer(iv, izeta)]
> 				= zeta_wts[izeta]*MT_loc;
> 			VEC_n2_PPhi_tilde[NB2_indexer(iv, izeta)]
> 				= place_in_range( K_phi_local + PPhi_tilde_loc,
> 									Kphi_min, Kphi_max);
> 			VEC_n2_PPhi_tildeFLIP[NB2_indexer(iv, izeta)]
> 				= place_in_range( K_phi_local - PPhi_tilde_loc,
> 									Kphi_min, Kphi_max);
> 
> 			VEC_n2_PT[NB2_indexer(iv, izeta)]
> 				= PT_loc;
> 
1302,1305c1525,1532
< 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+0][0] = MT_loc * cosh(P_Y_loc);
< 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+0][1] = PT_loc * cos(K_phi_local + PPhi_tilde_loc);
< 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+0][2] = PT_loc * sin(K_phi_local + PPhi_tilde_loc);
< 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+0][3] = MT_loc * sinh(P_Y_loc);
---
> 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+0][0]
> 				= MT_loc * cosh(P_Y_loc);
> 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+0][1]
> 				= PT_loc * cos(K_phi_local + PPhi_tilde_loc);
> 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+0][2]
> 				= PT_loc * sin(K_phi_local + PPhi_tilde_loc);
> 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+0][3]
> 				= MT_loc * sinh(P_Y_loc);
1307,1310c1534,1541
< 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+1][0] = MT_loc * cosh(P_Y_loc);
< 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+1][1] = PT_loc * cos(K_phi_local - PPhi_tilde_loc);
< 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+1][2] = PT_loc * sin(K_phi_local - PPhi_tilde_loc);
< 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+1][3] = MT_loc * sinh(P_Y_loc);
---
> 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+1][0]
> 				= MT_loc * cosh(P_Y_loc);
> 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+1][1]
> 				= PT_loc * cos(K_phi_local - PPhi_tilde_loc);
> 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+1][2]
> 				= PT_loc * sin(K_phi_local - PPhi_tilde_loc);
> 			VEC_n2_Ppm[NB2_indexer(iv, izeta)*2+1][3]
> 				= MT_loc * sinh(P_Y_loc);
1319c1550,1551
< void CorrelationFunction::Load_decay_channel_info_nb3(int dc_idx, double K_T_local, double K_phi_local, double K_y_local)
---
> void CorrelationFunction::Load_decay_channel_info_nb3(
> 		int dc_idx, double K_T_local, double K_phi_local, double K_y_local)
1321,1340c1553,1577
< 	Mres = current_resonance_mass;
< 	Gamma = current_resonance_Gamma;
< 	one_by_Gamma_Mres = 1./(Gamma*Mres + 1.e-25);	//keeps calculation safe when Gamma == 0
< 	//N.B. - no need for hbarc, since this will only multiply something with GeV^2 units in the end
< 	mass = current_daughter_mass;
< 	br = current_resonance_direct_br;	//doesn't depend on target daughter particle, just parent resonance and decay channel
< 	m2 = current_resonance_decay_masses[0];
< 	m3 = current_resonance_decay_masses[1];
< 
< 	pT = K_T_local;
< 	current_K_phi = K_phi_local;
< 	p_y = K_y_local;
< 
< 	n_body = current_reso_nbody;
< 
< 	mT = sqrt(mass*mass + pT*pT);
< 	double s_min_temp = (m2 + m3)*(m2 + m3);
< 	double s_max_temp = (Mres - mass)*(Mres - mass);
< 	gauss_quadrature(n_s_pts, 1, 0.0, 0.0, s_min_temp, s_max_temp, s_pts, s_wts);
< 	Qfunc = get_Q();
---
> 	Mres				= current_resonance_mass;
> 	Gamma				= current_resonance_Gamma;
> 	one_by_Gamma_Mres	= 1./(Gamma*Mres + 1.e-25);
> 	//N.B. - no need for hbarc, since this will only multiply
> 	// something with GeV^2 units in the end
> 	mass				= current_daughter_mass;
> 	//doesn't depend on target daughter particle,
> 	//just parent resonance and decay channel
> 	br					= current_resonance_direct_br;
> 	m2					= current_resonance_decay_masses[0];
> 	m3					= current_resonance_decay_masses[1];
> 
> 	pT					= K_T_local;
> 	current_K_phi		= K_phi_local;
> 	p_y				= K_y_local;
> 
> 	n_body				= current_reso_nbody;
> 
> 	mT					= sqrt(mass*mass + pT*pT);
> 	double s_min_temp	= (m2 + m3)*(m2 + m3);
> 	double s_max_temp	= (Mres - mass)*(Mres - mass);
> 	gauss_quadrature(n_s_pts, 1, 0.0, 0.0,
> 						s_min_temp, s_max_temp, s_pts, s_wts);
> 	// compute Q function to get denominator
> 	Qfunc				= get_Q();
1346,1351c1583,1590
< 		double s_loc = s_pts[is];
< 		double g_s_loc = g(s_loc);
< 		double pstar_loc = sqrt(((Mres+mass)*(Mres+mass) - s_loc)*((Mres-mass)*(Mres-mass) - s_loc))/(2.0*Mres);
< 		double Estar_loc = sqrt(mass*mass + pstar_loc*pstar_loc);
< 		double psBmT = pstar_loc / mT;
< 		double DeltaY_loc = log(psBmT + sqrt(1.+psBmT*psBmT));
---
> 		double s_loc		= s_pts[is];
> 		double g_s_loc		= g(s_loc);
> 		double pstar_loc	= sqrt( ((Mres+mass)*(Mres+mass) - s_loc)
> 									*((Mres-mass)*(Mres-mass) - s_loc)
> 									)/(2.0*Mres);
> 		double Estar_loc	= sqrt(mass*mass + pstar_loc*pstar_loc);
> 		double psBmT		= pstar_loc / mT;
> 		double DeltaY_loc	= log(psBmT + sqrt(1.+psBmT*psBmT));
1353c1592
< 		VEC_n3_s_factor[is] = s_wts[is]*g_s_loc;
---
> 		VEC_n3_s_factor[is] = s_wts[is] * g_s_loc;
1358,1366c1597,1607
< 			double v_loc = v_pts[iv];
< 			double P_Y_loc = p_y + v_loc*DeltaY_loc;
< 			double mT_ch_P_Y_p_y = mT*cosh(v_loc*DeltaY_loc);
< 			double x2 = mT_ch_P_Y_p_y*mT_ch_P_Y_p_y - pT*pT;
< 			double MTbar_loc = Estar_loc*Mres*mT_ch_P_Y_p_y/x2;
< 			double DeltaMT_loc = Mres*pT*sqrt(Estar_loc*Estar_loc - x2)/x2;
< 
< 			VEC_n3_P_Y[is * n_v_pts + iv] = P_Y_loc;
< 			VEC_n3_v_factor[is * n_v_pts + iv] = v_wts[iv]*DeltaY_loc/sqrt(x2);
---
> 			double v_loc			= v_pts[iv];
> 			double P_Y_loc			= p_y + v_loc*DeltaY_loc;
> 			double mT_ch_P_Y_p_y	= mT*cosh(v_loc*DeltaY_loc);
> 			double x2				= mT_ch_P_Y_p_y*mT_ch_P_Y_p_y - pT*pT;
> 			double MTbar_loc		= Estar_loc*Mres*mT_ch_P_Y_p_y/x2;
> 			double DeltaMT_loc		= Mres*pT*sqrt(Estar_loc*Estar_loc - x2)/x2;
> 
> 			VEC_n3_P_Y[is * n_v_pts + iv]
> 				= P_Y_loc;
> 			VEC_n3_v_factor[is * n_v_pts + iv]
> 				= v_wts[iv]*DeltaY_loc/sqrt(x2);
1371,1382c1612,1641
< 				double zeta_loc = zeta_pts[izeta];
< 				double MT_loc = MTbar_loc + cos(zeta_loc)*DeltaMT_loc;
< 				double PT_loc = sqrt(MT_loc*MT_loc - Mres*Mres);
< 				double temp_cos_PPhi_tilde_loc = (mT*MT_loc*cosh(P_Y_loc-p_y) - Estar_loc*Mres)/(pT*PT_loc);
< 				//assume that PPhi_tilde is +ve in next step...
< 				double temp_sin_PPhi_tilde_loc = sqrt(1. - temp_cos_PPhi_tilde_loc*temp_cos_PPhi_tilde_loc);
< 				double PPhi_tilde_loc = place_in_range( atan2(temp_sin_PPhi_tilde_loc, temp_cos_PPhi_tilde_loc), Kphi_min, Kphi_max);
< 
< 				VEC_n3_zeta_factor[NB3_indexer(is, iv, izeta)] = zeta_wts[izeta]*MT_loc;
< 				VEC_n3_PPhi_tilde[NB3_indexer(is, iv, izeta)] = place_in_range( K_phi_local + PPhi_tilde_loc, Kphi_min, Kphi_max);
< 				VEC_n3_PPhi_tildeFLIP[NB3_indexer(is, iv, izeta)] = place_in_range( K_phi_local - PPhi_tilde_loc, Kphi_min, Kphi_max);
< 				VEC_n3_PT[NB3_indexer(is, iv, izeta)] = PT_loc;
---
> 				double zeta_loc
> 					= zeta_pts[izeta];
> 				double MT_loc
> 					= MTbar_loc + cos(zeta_loc)*DeltaMT_loc;
> 				double PT_loc
> 					= sqrt(MT_loc*MT_loc - Mres*Mres);
> 				double temp_cos_PPhi_tilde_loc
> 					= ( mT*MT_loc*cosh(P_Y_loc-p_y)
> 						- Estar_loc*Mres )/(pT*PT_loc);
> 				//assume that PPhi_tilde is positive in next step...
> 				double temp_sin_PPhi_tilde_loc
> 					= sqrt( 1. - temp_cos_PPhi_tilde_loc
> 								* temp_cos_PPhi_tilde_loc );
> 				double PPhi_tilde_loc
> 					= place_in_range( atan2(temp_sin_PPhi_tilde_loc,
> 										temp_cos_PPhi_tilde_loc),
> 										Kphi_min, Kphi_max);
> 
> 				VEC_n3_zeta_factor[NB3_indexer(is, iv, izeta)]
> 					= zeta_wts[izeta]*MT_loc;
> 				VEC_n3_PPhi_tilde[NB3_indexer(is, iv, izeta)]
> 					= place_in_range( K_phi_local + PPhi_tilde_loc,
> 										Kphi_min, Kphi_max);
> 				VEC_n3_PPhi_tildeFLIP[NB3_indexer(is, iv, izeta)]
> 					= place_in_range( K_phi_local - PPhi_tilde_loc,
> 										Kphi_min, Kphi_max);
> 
> 				VEC_n3_PT[NB3_indexer(is, iv, izeta)]
> 					= PT_loc;
> 
1384,1387c1643,1650
< 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+0][0] = MT_loc * cosh(P_Y_loc);
< 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+0][1] = PT_loc * cos(K_phi_local + PPhi_tilde_loc);
< 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+0][2] = PT_loc * sin(K_phi_local + PPhi_tilde_loc);
< 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+0][3] = MT_loc * sinh(P_Y_loc);
---
> 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+0][0]
> 					= MT_loc * cosh(P_Y_loc);
> 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+0][1]
> 					= PT_loc * cos(K_phi_local + PPhi_tilde_loc);
> 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+0][2]
> 					= PT_loc * sin(K_phi_local + PPhi_tilde_loc);
> 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+0][3]
> 					= MT_loc * sinh(P_Y_loc);
1389,1392c1652,1659
< 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+1][0] = MT_loc * cosh(P_Y_loc);
< 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+1][1] = PT_loc * cos(K_phi_local - PPhi_tilde_loc);
< 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+1][2] = PT_loc * sin(K_phi_local - PPhi_tilde_loc);
< 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+1][3] = MT_loc * sinh(P_Y_loc);
---
> 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+1][0]
> 					= MT_loc * cosh(P_Y_loc);
> 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+1][1]
> 					= PT_loc * cos(K_phi_local - PPhi_tilde_loc);
> 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+1][2]
> 					= PT_loc * sin(K_phi_local - PPhi_tilde_loc);
> 				VEC_n3_Ppm[NB3_indexer(is, iv, izeta)*2+1][3]
> 					= MT_loc * sinh(P_Y_loc);
1402,1405c1669,1672
< 	fleshed_out_CF = new double ** [new_nqxpts];
< 	fleshed_out_thermal = new double ** [new_nqxpts];
< 	fleshed_out_crossterm = new double ** [new_nqxpts];
< 	fleshed_out_resonances = new double ** [new_nqxpts];
---
> 	fleshed_out_CF			= new double ** [new_nqxpts];
> 	fleshed_out_thermal	= new double ** [new_nqxpts];
> 	fleshed_out_crossterm	= new double ** [new_nqxpts];
> 	fleshed_out_resonances	= new double ** [new_nqxpts];
1408,1410c1675,1677
< 		fleshed_out_CF[iqx] = new double * [new_nqypts];
< 		fleshed_out_thermal[iqx] = new double * [new_nqypts];
< 		fleshed_out_crossterm[iqx] = new double * [new_nqypts];
---
> 		fleshed_out_CF[iqx]		= new double * [new_nqypts];
> 		fleshed_out_thermal[iqx]	= new double * [new_nqypts];
> 		fleshed_out_crossterm[iqx]	= new double * [new_nqypts];
1414,1417c1681,1684
< 			fleshed_out_CF[iqx][iqy] = new double [new_nqzpts];
< 			fleshed_out_thermal[iqx][iqy] = new double [new_nqzpts];
< 			fleshed_out_crossterm[iqx][iqy] = new double [new_nqzpts];
< 			fleshed_out_resonances[iqx][iqy] = new double [new_nqzpts];
---
> 			fleshed_out_CF[iqx][iqy]			= new double [new_nqzpts];
> 			fleshed_out_thermal[iqx][iqy]		= new double [new_nqzpts];
> 			fleshed_out_crossterm[iqx][iqy]		= new double [new_nqzpts];
> 			fleshed_out_resonances[iqx][iqy]	= new double [new_nqzpts];
1420,1423c1687,1690
< 				fleshed_out_CF[iqx][iqy][iqz] = 0.0;
< 				fleshed_out_thermal[iqx][iqy][iqz] = 0.0;
< 				fleshed_out_crossterm[iqx][iqy][iqz] = 0.0;
< 				fleshed_out_resonances[iqx][iqy][iqz] = 0.0;
---
> 				fleshed_out_CF[iqx][iqy][iqz]			= 0.0;
> 				fleshed_out_thermal[iqx][iqy][iqz]		= 0.0;
> 				fleshed_out_crossterm[iqx][iqy][iqz]	= 0.0;
> 				fleshed_out_resonances[iqx][iqy][iqz]	= 0.0;
1463c1730,1731
< /*void CorrelationFunction::Set_Y_eq_0_Bessel_grids(int iqt, int iqz, double * BC_chunk)
---
> /*void CorrelationFunction::Set_Y_eq_0_Bessel_grids(
> 		int iqt, int iqz, double * BC_chunk)
1597c1865,1866
< void CorrelationFunction::Set_all_Bessel_grids(int iqt, int iqz, int particle_mode /*==0*/)
---
> void CorrelationFunction::Set_all_Bessel_grids(
> 		int iqt, int iqz, int particle_mode /*==0*/)
1600,1610c1869,1871
< 	int na = n_alpha_points;
< 	double alpha_min = 4.0;
< 	//double alpha_max = 75.0;
< 	//double alpha_max = 150.0;
< 	double alpha_max = 200.0;
< 	/*if (particle_mode)
< 	{
< 		na = n_alpha_points_PIONS;
< 		alpha_min = 0.5;
< 		alpha_max = 400.0;
< 	}*/
---
> 	int na				= n_alpha_points;
> 	double alpha_min	= 4.0;
> 	double alpha_max	= 200.0;
1612c1873
< 	int n_coeffs = na;
---
> 	int n_coeffs		= na;
1614,1616c1875,1877
< 	double * dummy = new double [na];
< 	double * alpha_pts = new double [na];
< 	double * x_pts = new double [na];
---
> 	double * dummy		= new double [na];
> 	double * alpha_pts	= new double [na];
> 	double * x_pts		= new double [na];
1620,1621c1881,1883
< 		x_pts[k] = - cos( M_PI*(2.*(k+1.) - 1.) / (2.*na) );
< 		alpha_pts[k] = 0.5*(x_pts[k] + 1.0)*(alpha_max - alpha_min) + alpha_min;
---
> 		x_pts[k]		= - cos( M_PI*(2.*(k+1.) - 1.) / (2.*na) );
> 		alpha_pts[k]	= 0.5 * (x_pts[k] + 1.0)
> 							* (alpha_max - alpha_min) + alpha_min;
1622a1885
> 
1628c1891
< 		dens[j] = 0.0;
---
> 		dens[j]				= 0.0;
1631,1633c1894,1896
< 			double Tjk = csf::Tfun(j, x_pts[k]);
< 			dens[j] += Tjk*Tjk;
< 			nums[j*na+k] = Tjk;
---
> 			double Tjk		= csf::Tfun(j, x_pts[k]);
> 			dens[j]		   += Tjk*Tjk;
> 			nums[j*na+k]	= Tjk;
1642c1905,1907
< 	int HDFcode = Administrate_besselcoeffs_HDF_array(0, particle_mode);	//initialize
---
> 	//initialize
> 	int HDFcode = Administrate_besselcoeffs_HDF_array(0, particle_mode);
> 	//if initialization unsuccessful, crash
1650,1654c1915,1918
< 	double loc_qt = qt_pts[iqt];
< 	double loc_qz = qz_pts[iqz];
< 	//current_pY_shift = - double(abs(loc_qz)>1.e-10) * asinh(loc_qz / sqrt(abs(loc_qt*loc_qt-loc_qz*loc_qz) + 1.e-100));
< 	current_pY_shift = 0.5 * log(abs((loc_qt+loc_qz + 1.e-100)/(loc_qt-loc_qz + 1.e-100)));
< 	//current_pY_shift = 0.0;
---
> 	double loc_qt		= qt_pts[iqt];
> 	double loc_qz		= qz_pts[iqz];
> 	current_pY_shift	= 0.5 * log( abs( (loc_qt+loc_qz + 1.e-100)
> 										/(loc_qt-loc_qz + 1.e-100) ) );
1656c1920
< 	double * BC_chunk = new double [4 * FO_length * na];
---
> 	double * BC_chunk	= new double [4 * FO_length * na];
1661c1925,1926
< 		cout << "Starting loop = " << iqt << "	 " << iqz << "	 " << ipY << endl;
---
> 		//cout << "Starting loop = "
> 		//		<< iqt << "   " << iqz << "   " << ipY << endl;
1663,1666c1928,1931
< 		ch_SP_pY[ipY] = cosh(SP_Del_pY[ipY] + current_pY_shift);
< 		sh_SP_pY[ipY] = sinh(SP_Del_pY[ipY] + current_pY_shift);
< 		double ch_pY = ch_SP_pY[ipY];
< 		double sh_pY = sh_SP_pY[ipY];
---
> 		ch_SP_pY[ipY]	= cosh(SP_Del_pY[ipY] + current_pY_shift);
> 		sh_SP_pY[ipY]	= sinh(SP_Del_pY[ipY] + current_pY_shift);
> 		double ch_pY	= ch_SP_pY[ipY];
> 		double sh_pY	= sh_SP_pY[ipY];
1668c1933
< 		int iBC = 0;
---
> 		int iBC			= 0;
1671c1936
< 			double tau = (&FOsurf_ptr[isurf])->tau;
---
> 			double tau		= (&FOsurf_ptr[isurf])->tau;
1673,1676c1938,1943
< 			double beta = tau * hbarCm1 * ( loc_qt*ch_pY - loc_qz*sh_pY );
< 			double gamma = tau * hbarCm1 * ( loc_qz*ch_pY - loc_qt*sh_pY );
< 			double gsq = gamma*gamma;
< //cout << "beta and gamma = " << beta << "   " << gamma << "   " << loc_qt << "	  " << loc_qz << "   " << ch_pY << "   " << sh_pY << endl;
---
> 			double beta	= tau * hbarCm1 * ( loc_qt*ch_pY - loc_qz*sh_pY );
> 			double gamma	= tau * hbarCm1 * ( loc_qz*ch_pY - loc_qt*sh_pY );
> 			double gsq		= gamma*gamma;
> 			//cout << "beta and gamma = " << beta << "   " << gamma
> 			//		<< "   " << loc_qt << "	  " << loc_qz << "   "
> 			//		<< ch_pY << "	" << sh_pY << endl;
1680,1685c1947,1957
< 				double loc_alpha = alpha_pts[ia];
< 				complex<double> ci0, ci1, ck0, ck1, ci0p, ci1p, ck0p, ck1p;
< 				complex<double> z0 = loc_alpha - i*beta;
< 				complex<double> z0sq = z0 * z0;
< 				complex<double> z = sqrt(z0sq + gsq);
< 				int errorCode = bessf::cbessik01(z, ci0, ci1, ck0, ck1, ci0p, ci1p, ck0p, ck1p);
---
> 				complex<double> ci0, ci1, ck0, ck1,
> 								ci0p, ci1p, ck0p, ck1p;
> 
> 				double loc_alpha		= alpha_pts[ia];
> 				complex<double> z0		= loc_alpha - i*beta;
> 				complex<double> z0sq	= z0 * z0;
> 				complex<double> z		= sqrt(z0sq + gsq);
> 				int errorCode			= bessf::cbessik01(
> 											z,
> 											ci0, ci1, ck0, ck1,
> 											ci0p, ci1p, ck0p, ck1p);
1687,1689c1959,1961
< 						|| isnan(ck0.imag())
< 						|| isnan(ck1.real())
< 						|| isnan(ck1.imag()) )
---
> 						or isnan(ck0.imag())
> 						or isnan(ck1.real())
> 						or isnan(ck1.imag()) )
1691c1963,1967
< 					cout << loc_alpha << "	 " << beta << "	  " << gamma << "   " << z << "	  " << ck0 << "	  " << ck1 << endl;
---
> 					cerr << "WARNING: Obtained NaNs in "
> 							<< "complex Bessel functions: "
> 							<< loc_alpha << "   " << beta << "   "
> 							<< gamma << "	" << z << "   "
> 							<< ck0 << "   " << ck1 << endl;
1692a1969
> 
1703c1980,1981
< 			//separate out 0th coefficient for additional factor of 2.0
---
> 			//separate out 0th coefficient for
> 			//additional factor of 2.0
1706c1984,1985
< 				coeffs_array[0] += 2.0*expBesselK0re[k] * nums[0*na+k];
---
> 				coeffs_array[0] += 2.0*expBesselK0re[k]
> 									* nums[0*na+k];
1708c1987
< 			//cout << "a" << 0 << " = " << coeffs_array[0] / dens[0] << endl;
---
> 
1713c1992,1993
< 					coeffs_array[j] += expBesselK0re[k] * nums[j*na+k];
---
> 					coeffs_array[j] += expBesselK0re[k]
> 										* nums[j*na+k];
1715d1994
< 			//cout << "a" << j << " = " << coeffs_array[j] / dens[j] << endl;
1717d1995
< //if (1) exit(8);
1724c2002,2003
< 				coeffs_array[0] += 2.0*expBesselK0im[k] * nums[0*na+k];
---
> 				coeffs_array[0] += 2.0*expBesselK0im[k]
> 									* nums[0*na+k];
1730c2009,2010
< 					coeffs_array[j] += expBesselK0im[k] * nums[j*na+k];
---
> 					coeffs_array[j] += expBesselK0im[k]
> 										* nums[j*na+k];
1739c2019,2020
< 				coeffs_array[0] += 2.0*expBesselK1re[k] * nums[0*na+k];
---
> 				coeffs_array[0] += 2.0*expBesselK1re[k]
> 									* nums[0*na+k];
1745c2026,2027
< 					coeffs_array[j] += expBesselK1re[k] * nums[j*na+k];
---
> 					coeffs_array[j] += expBesselK1re[k]
> 										* nums[j*na+k];
1754c2036,2037
< 				coeffs_array[0] += 2.0*expBesselK1im[k] * nums[0*na+k];
---
> 				coeffs_array[0] += 2.0*expBesselK1im[k]
> 									* nums[0*na+k];
1760c2043,2044
< 					coeffs_array[j] += expBesselK1im[k] * nums[j*na+k];
---
> 					coeffs_array[j] += expBesselK1im[k]
> 										* nums[j*na+k];
1763d2046
< 			//cout << "Just set " << iBC - 1 << " of " << 4 * FO_length * n_alpha_points << "-length array." << endl;
1767c2050,2052
< 		HDFcode = Access_besselcoeffs_in_HDF_array(ipY, 0, BC_chunk, particle_mode);	// 0 - set
---
> 		// 0 - set
> 		HDFcode = Access_besselcoeffs_in_HDF_array(ipY, 0, BC_chunk,
> 													particle_mode);
1770c2055,2057
< 		cout << "Finished in " << sw_loop.printTime() << " seconds." << endl;
---
> 		*out << "Finished in "
> 				<< sw_loop.printTime()
> 				<< " seconds." << endl;
1773c2060,2061
< 	HDFcode = Administrate_besselcoeffs_HDF_array(2, particle_mode);	// 2 - close
---
> 	// 2 - close
> 	HDFcode = Administrate_besselcoeffs_HDF_array(2, particle_mode);
1782c2070
< 	cout << "Finished setting Bessel grids successfully." << endl;
---
> 	*out << "Finished setting Bessel grids successfully." << endl;
